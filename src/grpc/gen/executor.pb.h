// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: executor.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_executor_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_executor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_executor_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_executor_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_executor_2eproto;
namespace executor {
namespace v1 {
class CallTrace;
struct CallTraceDefaultTypeInternal;
extern CallTraceDefaultTypeInternal _CallTrace_default_instance_;
class Contract;
struct ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class ExecutionTraceStep;
struct ExecutionTraceStepDefaultTypeInternal;
extern ExecutionTraceStepDefaultTypeInternal _ExecutionTraceStep_default_instance_;
class ExecutionTraceStep_StorageEntry_DoNotUse;
struct ExecutionTraceStep_StorageEntry_DoNotUseDefaultTypeInternal;
extern ExecutionTraceStep_StorageEntry_DoNotUseDefaultTypeInternal _ExecutionTraceStep_StorageEntry_DoNotUse_default_instance_;
class GetFlushStatusResponse;
struct GetFlushStatusResponseDefaultTypeInternal;
extern GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
class InfoReadWrite;
struct InfoReadWriteDefaultTypeInternal;
extern InfoReadWriteDefaultTypeInternal _InfoReadWrite_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class ProcessBatchRequest;
struct ProcessBatchRequestDefaultTypeInternal;
extern ProcessBatchRequestDefaultTypeInternal _ProcessBatchRequest_default_instance_;
class ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse;
struct ProcessBatchRequest_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequest_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse_default_instance_;
class ProcessBatchRequest_DbEntry_DoNotUse;
struct ProcessBatchRequest_DbEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequest_DbEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequest_DbEntry_DoNotUse_default_instance_;
class ProcessBatchResponse;
struct ProcessBatchResponseDefaultTypeInternal;
extern ProcessBatchResponseDefaultTypeInternal _ProcessBatchResponse_default_instance_;
class ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse;
struct ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUseDefaultTypeInternal _ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse_default_instance_;
class ProcessTransactionResponse;
struct ProcessTransactionResponseDefaultTypeInternal;
extern ProcessTransactionResponseDefaultTypeInternal _ProcessTransactionResponse_default_instance_;
class TraceConfig;
struct TraceConfigDefaultTypeInternal;
extern TraceConfigDefaultTypeInternal _TraceConfig_default_instance_;
class TransactionContext;
struct TransactionContextDefaultTypeInternal;
extern TransactionContextDefaultTypeInternal _TransactionContext_default_instance_;
class TransactionStep;
struct TransactionStepDefaultTypeInternal;
extern TransactionStepDefaultTypeInternal _TransactionStep_default_instance_;
}  // namespace v1
}  // namespace executor
PROTOBUF_NAMESPACE_OPEN
template<> ::executor::v1::CallTrace* Arena::CreateMaybeMessage<::executor::v1::CallTrace>(Arena*);
template<> ::executor::v1::Contract* Arena::CreateMaybeMessage<::executor::v1::Contract>(Arena*);
template<> ::executor::v1::ExecutionTraceStep* Arena::CreateMaybeMessage<::executor::v1::ExecutionTraceStep>(Arena*);
template<> ::executor::v1::ExecutionTraceStep_StorageEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ExecutionTraceStep_StorageEntry_DoNotUse>(Arena*);
template<> ::executor::v1::GetFlushStatusResponse* Arena::CreateMaybeMessage<::executor::v1::GetFlushStatusResponse>(Arena*);
template<> ::executor::v1::InfoReadWrite* Arena::CreateMaybeMessage<::executor::v1::InfoReadWrite>(Arena*);
template<> ::executor::v1::Log* Arena::CreateMaybeMessage<::executor::v1::Log>(Arena*);
template<> ::executor::v1::ProcessBatchRequest* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest>(Arena*);
template<> ::executor::v1::ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequest_DbEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest_DbEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchResponse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchResponse>(Arena*);
template<> ::executor::v1::ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessTransactionResponse* Arena::CreateMaybeMessage<::executor::v1::ProcessTransactionResponse>(Arena*);
template<> ::executor::v1::TraceConfig* Arena::CreateMaybeMessage<::executor::v1::TraceConfig>(Arena*);
template<> ::executor::v1::TransactionContext* Arena::CreateMaybeMessage<::executor::v1::TransactionContext>(Arena*);
template<> ::executor::v1::TransactionStep* Arena::CreateMaybeMessage<::executor::v1::TransactionStep>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace executor {
namespace v1 {

enum RomError : int {
  ROM_ERROR_UNSPECIFIED = 0,
  ROM_ERROR_NO_ERROR = 1,
  ROM_ERROR_OUT_OF_GAS = 2,
  ROM_ERROR_STACK_OVERFLOW = 3,
  ROM_ERROR_STACK_UNDERFLOW = 4,
  ROM_ERROR_MAX_CODE_SIZE_EXCEEDED = 5,
  ROM_ERROR_CONTRACT_ADDRESS_COLLISION = 6,
  ROM_ERROR_EXECUTION_REVERTED = 7,
  ROM_ERROR_OUT_OF_COUNTERS_STEP = 8,
  ROM_ERROR_OUT_OF_COUNTERS_KECCAK = 9,
  ROM_ERROR_OUT_OF_COUNTERS_BINARY = 10,
  ROM_ERROR_OUT_OF_COUNTERS_MEM = 11,
  ROM_ERROR_OUT_OF_COUNTERS_ARITH = 12,
  ROM_ERROR_OUT_OF_COUNTERS_PADDING = 13,
  ROM_ERROR_OUT_OF_COUNTERS_POSEIDON = 14,
  ROM_ERROR_INVALID_JUMP = 15,
  ROM_ERROR_INVALID_OPCODE = 16,
  ROM_ERROR_INVALID_STATIC = 17,
  ROM_ERROR_INVALID_BYTECODE_STARTS_EF = 18,
  ROM_ERROR_INTRINSIC_INVALID_SIGNATURE = 19,
  ROM_ERROR_INTRINSIC_INVALID_CHAIN_ID = 20,
  ROM_ERROR_INTRINSIC_INVALID_NONCE = 21,
  ROM_ERROR_INTRINSIC_INVALID_GAS_LIMIT = 22,
  ROM_ERROR_INTRINSIC_INVALID_BALANCE = 23,
  ROM_ERROR_INTRINSIC_INVALID_BATCH_GAS_LIMIT = 24,
  ROM_ERROR_INTRINSIC_INVALID_SENDER_CODE = 25,
  ROM_ERROR_INTRINSIC_TX_GAS_OVERFLOW = 26,
  ROM_ERROR_BATCH_DATA_TOO_BIG = 27,
  ROM_ERROR_UNSUPPORTED_FORK_ID = 28,
  ROM_ERROR_INVALID_RLP = 29,
  RomError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RomError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RomError_IsValid(int value);
constexpr RomError RomError_MIN = ROM_ERROR_UNSPECIFIED;
constexpr RomError RomError_MAX = ROM_ERROR_INVALID_RLP;
constexpr int RomError_ARRAYSIZE = RomError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RomError_descriptor();
template<typename T>
inline const std::string& RomError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RomError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RomError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RomError_descriptor(), enum_t_value);
}
inline bool RomError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RomError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RomError>(
    RomError_descriptor(), name, value);
}
enum ExecutorError : int {
  EXECUTOR_ERROR_UNSPECIFIED = 0,
  EXECUTOR_ERROR_NO_ERROR = 1,
  EXECUTOR_ERROR_DB_ERROR = 2,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_STEPS = 3,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_KECCAK = 4,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_BINARY = 5,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_MEM = 6,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_ARITH = 7,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_PADDING = 8,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_POSEIDON = 9,
  EXECUTOR_ERROR_UNSUPPORTED_FORK_ID = 10,
  EXECUTOR_ERROR_BALANCE_MISMATCH = 11,
  EXECUTOR_ERROR_FEA2SCALAR = 12,
  EXECUTOR_ERROR_TOS32 = 13,
  EXECUTOR_ERROR_SM_MAIN_INVALID_UNSIGNED_TX = 14,
  EXECUTOR_ERROR_SM_MAIN_INVALID_NO_COUNTERS = 15,
  EXECUTOR_ERROR_SM_MAIN_ARITH_ECRECOVER_DIVIDE_BY_ZERO = 16,
  EXECUTOR_ERROR_SM_MAIN_ADDRESS_OUT_OF_RANGE = 17,
  EXECUTOR_ERROR_SM_MAIN_ADDRESS_NEGATIVE = 18,
  EXECUTOR_ERROR_SM_MAIN_STORAGE_INVALID_KEY = 19,
  EXECUTOR_ERROR_SM_MAIN_HASHK = 20,
  EXECUTOR_ERROR_SM_MAIN_HASHK_SIZE_OUT_OF_RANGE = 21,
  EXECUTOR_ERROR_SM_MAIN_HASHK_POSITION_NEGATIVE = 22,
  EXECUTOR_ERROR_SM_MAIN_HASHK_POSITION_PLUS_SIZE_OUT_OF_RANGE = 23,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_ADDRESS_NOT_FOUND = 24,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_NOT_COMPLETED = 25,
  EXECUTOR_ERROR_SM_MAIN_HASHP = 26,
  EXECUTOR_ERROR_SM_MAIN_HASHP_SIZE_OUT_OF_RANGE = 27,
  EXECUTOR_ERROR_SM_MAIN_HASHP_POSITION_NEGATIVE = 28,
  EXECUTOR_ERROR_SM_MAIN_HASHP_POSITION_PLUS_SIZE_OUT_OF_RANGE = 29,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_ADDRESS_NOT_FOUND = 30,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_NOT_COMPLETED = 31,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_OFFSET_OUT_OF_RANGE = 32,
  EXECUTOR_ERROR_SM_MAIN_MULTIPLE_FREEIN = 33,
  EXECUTOR_ERROR_SM_MAIN_ASSERT = 34,
  EXECUTOR_ERROR_SM_MAIN_MEMORY = 35,
  EXECUTOR_ERROR_SM_MAIN_STORAGE_READ_MISMATCH = 36,
  EXECUTOR_ERROR_SM_MAIN_STORAGE_WRITE_MISMATCH = 37,
  EXECUTOR_ERROR_SM_MAIN_HASHK_VALUE_MISMATCH = 38,
  EXECUTOR_ERROR_SM_MAIN_HASHK_PADDING_MISMATCH = 39,
  EXECUTOR_ERROR_SM_MAIN_HASHK_SIZE_MISMATCH = 40,
  EXECUTOR_ERROR_SM_MAIN_HASHKLEN_LENGTH_MISMATCH = 41,
  EXECUTOR_ERROR_SM_MAIN_HASHKLEN_CALLED_TWICE = 42,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_NOT_FOUND = 43,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_DIGEST_MISMATCH = 44,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_CALLED_TWICE = 45,
  EXECUTOR_ERROR_SM_MAIN_HASHP_VALUE_MISMATCH = 46,
  EXECUTOR_ERROR_SM_MAIN_HASHP_PADDING_MISMATCH = 47,
  EXECUTOR_ERROR_SM_MAIN_HASHP_SIZE_MISMATCH = 48,
  EXECUTOR_ERROR_SM_MAIN_HASHPLEN_LENGTH_MISMATCH = 49,
  EXECUTOR_ERROR_SM_MAIN_HASHPLEN_CALLED_TWICE = 50,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_DIGEST_MISMATCH = 51,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_CALLED_TWICE = 52,
  EXECUTOR_ERROR_SM_MAIN_ARITH_MISMATCH = 53,
  EXECUTOR_ERROR_SM_MAIN_ARITH_ECRECOVER_MISMATCH = 54,
  EXECUTOR_ERROR_SM_MAIN_BINARY_ADD_MISMATCH = 55,
  EXECUTOR_ERROR_SM_MAIN_BINARY_SUB_MISMATCH = 56,
  EXECUTOR_ERROR_SM_MAIN_BINARY_LT_MISMATCH = 57,
  EXECUTOR_ERROR_SM_MAIN_BINARY_SLT_MISMATCH = 58,
  EXECUTOR_ERROR_SM_MAIN_BINARY_EQ_MISMATCH = 59,
  EXECUTOR_ERROR_SM_MAIN_BINARY_AND_MISMATCH = 60,
  EXECUTOR_ERROR_SM_MAIN_BINARY_OR_MISMATCH = 61,
  EXECUTOR_ERROR_SM_MAIN_BINARY_XOR_MISMATCH = 62,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_WRITE_MISMATCH = 63,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_WRITE8_MISMATCH = 64,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_READ_MISMATCH = 65,
  EXECUTOR_ERROR_SM_MAIN_JMPN_OUT_OF_RANGE = 66,
  EXECUTOR_ERROR_SM_MAIN_HASHK_READ_OUT_OF_RANGE = 67,
  EXECUTOR_ERROR_SM_MAIN_HASHP_READ_OUT_OF_RANGE = 68,
  EXECUTOR_ERROR_INVALID_OLD_STATE_ROOT = 69,
  EXECUTOR_ERROR_INVALID_OLD_ACC_INPUT_HASH = 70,
  EXECUTOR_ERROR_INVALID_CHAIN_ID = 71,
  EXECUTOR_ERROR_INVALID_BATCH_L2_DATA = 72,
  EXECUTOR_ERROR_INVALID_GLOBAL_EXIT_ROOT = 73,
  EXECUTOR_ERROR_INVALID_COINBASE = 74,
  EXECUTOR_ERROR_INVALID_FROM = 75,
  EXECUTOR_ERROR_INVALID_DB_KEY = 76,
  EXECUTOR_ERROR_INVALID_DB_VALUE = 77,
  EXECUTOR_ERROR_INVALID_CONTRACTS_BYTECODE_KEY = 78,
  EXECUTOR_ERROR_INVALID_CONTRACTS_BYTECODE_VALUE = 79,
  EXECUTOR_ERROR_INVALID_GET_KEY = 80,
  ExecutorError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecutorError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecutorError_IsValid(int value);
constexpr ExecutorError ExecutorError_MIN = EXECUTOR_ERROR_UNSPECIFIED;
constexpr ExecutorError ExecutorError_MAX = EXECUTOR_ERROR_INVALID_GET_KEY;
constexpr int ExecutorError_ARRAYSIZE = ExecutorError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutorError_descriptor();
template<typename T>
inline const std::string& ExecutorError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutorError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutorError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecutorError_descriptor(), enum_t_value);
}
inline bool ExecutorError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutorError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutorError>(
    ExecutorError_descriptor(), name, value);
}
// ===================================================================

class ProcessBatchRequest_DbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessBatchRequest_DbEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest_DbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequest_DbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequest_DbEntry_DoNotUse& other);
  static const ProcessBatchRequest_DbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequest_DbEntry_DoNotUse*>(&_ProcessBatchRequest_DbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.DbEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.DbEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse& other);
  static const ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse*>(&_ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.ContractsBytecodeEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.ContractsBytecodeEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBatchRequest) */ {
 public:
  inline ProcessBatchRequest() : ProcessBatchRequest(nullptr) {}
  ~ProcessBatchRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBatchRequest(const ProcessBatchRequest& from);
  ProcessBatchRequest(ProcessBatchRequest&& from) noexcept
    : ProcessBatchRequest() {
    *this = ::std::move(from);
  }

  inline ProcessBatchRequest& operator=(const ProcessBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBatchRequest& operator=(ProcessBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBatchRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessBatchRequest*>(
               &_ProcessBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProcessBatchRequest& a, ProcessBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBatchRequest& from) {
    ProcessBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBatchRequest";
  }
  protected:
  explicit ProcessBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDbFieldNumber = 13,
    kContractsBytecodeFieldNumber = 14,
    kOldStateRootFieldNumber = 1,
    kOldAccInputHashFieldNumber = 2,
    kBatchL2DataFieldNumber = 6,
    kGlobalExitRootFieldNumber = 7,
    kCoinbaseFieldNumber = 9,
    kFromFieldNumber = 12,
    kContextIdFieldNumber = 16,
    kTraceConfigFieldNumber = 15,
    kOldBatchNumFieldNumber = 3,
    kChainIdFieldNumber = 4,
    kForkIdFieldNumber = 5,
    kEthTimestampFieldNumber = 8,
    kNoCountersFieldNumber = 11,
    kUpdateMerkleTreeFieldNumber = 10,
    kGetKeysFieldNumber = 17,
  };
  // map<string, string> db = 13;
  int db_size() const;
  private:
  int _internal_db_size() const;
  public:
  void clear_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_db();

  // map<string, string> contracts_bytecode = 14;
  int contracts_bytecode_size() const;
  private:
  int _internal_contracts_bytecode_size() const;
  public:
  void clear_contracts_bytecode();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_contracts_bytecode();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_contracts_bytecode();

  // bytes old_state_root = 1;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // bytes old_acc_input_hash = 2;
  void clear_old_acc_input_hash();
  const std::string& old_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_old_acc_input_hash();
  void set_allocated_old_acc_input_hash(std::string* old_acc_input_hash);
  private:
  const std::string& _internal_old_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_old_acc_input_hash();
  public:

  // bytes batch_l2_data = 6;
  void clear_batch_l2_data();
  const std::string& batch_l2_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_l2_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_l2_data();
  PROTOBUF_NODISCARD std::string* release_batch_l2_data();
  void set_allocated_batch_l2_data(std::string* batch_l2_data);
  private:
  const std::string& _internal_batch_l2_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_l2_data(const std::string& value);
  std::string* _internal_mutable_batch_l2_data();
  public:

  // bytes global_exit_root = 7;
  void clear_global_exit_root();
  const std::string& global_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_exit_root();
  PROTOBUF_NODISCARD std::string* release_global_exit_root();
  void set_allocated_global_exit_root(std::string* global_exit_root);
  private:
  const std::string& _internal_global_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_exit_root(const std::string& value);
  std::string* _internal_mutable_global_exit_root();
  public:

  // string coinbase = 9;
  void clear_coinbase();
  const std::string& coinbase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coinbase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coinbase();
  PROTOBUF_NODISCARD std::string* release_coinbase();
  void set_allocated_coinbase(std::string* coinbase);
  private:
  const std::string& _internal_coinbase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coinbase(const std::string& value);
  std::string* _internal_mutable_coinbase();
  public:

  // string from = 12;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string context_id = 16;
  void clear_context_id();
  const std::string& context_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context_id();
  PROTOBUF_NODISCARD std::string* release_context_id();
  void set_allocated_context_id(std::string* context_id);
  private:
  const std::string& _internal_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context_id(const std::string& value);
  std::string* _internal_mutable_context_id();
  public:

  // .executor.v1.TraceConfig trace_config = 15;
  bool has_trace_config() const;
  private:
  bool _internal_has_trace_config() const;
  public:
  void clear_trace_config();
  const ::executor::v1::TraceConfig& trace_config() const;
  PROTOBUF_NODISCARD ::executor::v1::TraceConfig* release_trace_config();
  ::executor::v1::TraceConfig* mutable_trace_config();
  void set_allocated_trace_config(::executor::v1::TraceConfig* trace_config);
  private:
  const ::executor::v1::TraceConfig& _internal_trace_config() const;
  ::executor::v1::TraceConfig* _internal_mutable_trace_config();
  public:
  void unsafe_arena_set_allocated_trace_config(
      ::executor::v1::TraceConfig* trace_config);
  ::executor::v1::TraceConfig* unsafe_arena_release_trace_config();

  // uint64 old_batch_num = 3;
  void clear_old_batch_num();
  uint64_t old_batch_num() const;
  void set_old_batch_num(uint64_t value);
  private:
  uint64_t _internal_old_batch_num() const;
  void _internal_set_old_batch_num(uint64_t value);
  public:

  // uint64 chain_id = 4;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 fork_id = 5;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // uint64 eth_timestamp = 8;
  void clear_eth_timestamp();
  uint64_t eth_timestamp() const;
  void set_eth_timestamp(uint64_t value);
  private:
  uint64_t _internal_eth_timestamp() const;
  void _internal_set_eth_timestamp(uint64_t value);
  public:

  // uint64 no_counters = 11;
  void clear_no_counters();
  uint64_t no_counters() const;
  void set_no_counters(uint64_t value);
  private:
  uint64_t _internal_no_counters() const;
  void _internal_set_no_counters(uint64_t value);
  public:

  // uint32 update_merkle_tree = 10;
  void clear_update_merkle_tree();
  uint32_t update_merkle_tree() const;
  void set_update_merkle_tree(uint32_t value);
  private:
  uint32_t _internal_update_merkle_tree() const;
  void _internal_set_update_merkle_tree(uint32_t value);
  public:

  // uint32 get_keys = 17;
  void clear_get_keys();
  uint32_t get_keys() const;
  void set_get_keys(uint32_t value);
  private:
  uint32_t _internal_get_keys() const;
  void _internal_set_get_keys(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchRequest_DbEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> db_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> contracts_bytecode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_l2_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coinbase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_id_;
    ::executor::v1::TraceConfig* trace_config_;
    uint64_t old_batch_num_;
    uint64_t chain_id_;
    uint64_t fork_id_;
    uint64_t eth_timestamp_;
    uint64_t no_counters_;
    uint32_t update_merkle_tree_;
    uint32_t get_keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse, 
    std::string, ::executor::v1::InfoReadWrite,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse, 
    std::string, ::executor::v1::InfoReadWrite,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse& other);
  static const ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse*>(&_ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchResponse.ReadWriteAddressesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBatchResponse) */ {
 public:
  inline ProcessBatchResponse() : ProcessBatchResponse(nullptr) {}
  ~ProcessBatchResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBatchResponse(const ProcessBatchResponse& from);
  ProcessBatchResponse(ProcessBatchResponse&& from) noexcept
    : ProcessBatchResponse() {
    *this = ::std::move(from);
  }

  inline ProcessBatchResponse& operator=(const ProcessBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBatchResponse& operator=(ProcessBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBatchResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessBatchResponse*>(
               &_ProcessBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProcessBatchResponse& a, ProcessBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBatchResponse& from) {
    ProcessBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBatchResponse";
  }
  protected:
  explicit ProcessBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 13,
    kReadWriteAddressesFieldNumber = 15,
    kNodesKeysFieldNumber = 19,
    kProgramKeysFieldNumber = 20,
    kNewStateRootFieldNumber = 1,
    kNewAccInputHashFieldNumber = 2,
    kNewLocalExitRootFieldNumber = 3,
    kProverIdFieldNumber = 18,
    kNewBatchNumFieldNumber = 4,
    kCntKeccakHashesFieldNumber = 5,
    kCntPoseidonHashesFieldNumber = 6,
    kCntPoseidonPaddingsFieldNumber = 7,
    kCntMemAlignsFieldNumber = 8,
    kCntArithmeticsFieldNumber = 9,
    kCntBinariesFieldNumber = 10,
    kCumulativeGasUsedFieldNumber = 12,
    kCntStepsFieldNumber = 11,
    kErrorFieldNumber = 14,
    kFlushIdFieldNumber = 16,
    kStoredFlushIdFieldNumber = 17,
  };
  // repeated .executor.v1.ProcessTransactionResponse responses = 13;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::executor::v1::ProcessTransactionResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >*
      mutable_responses();
  private:
  const ::executor::v1::ProcessTransactionResponse& _internal_responses(int index) const;
  ::executor::v1::ProcessTransactionResponse* _internal_add_responses();
  public:
  const ::executor::v1::ProcessTransactionResponse& responses(int index) const;
  ::executor::v1::ProcessTransactionResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >&
      responses() const;

  // map<string, .executor.v1.InfoReadWrite> read_write_addresses = 15;
  int read_write_addresses_size() const;
  private:
  int _internal_read_write_addresses_size() const;
  public:
  void clear_read_write_addresses();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
      _internal_read_write_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
      _internal_mutable_read_write_addresses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
      read_write_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
      mutable_read_write_addresses();

  // repeated bytes nodes_keys = 19;
  int nodes_keys_size() const;
  private:
  int _internal_nodes_keys_size() const;
  public:
  void clear_nodes_keys();
  const std::string& nodes_keys(int index) const;
  std::string* mutable_nodes_keys(int index);
  void set_nodes_keys(int index, const std::string& value);
  void set_nodes_keys(int index, std::string&& value);
  void set_nodes_keys(int index, const char* value);
  void set_nodes_keys(int index, const void* value, size_t size);
  std::string* add_nodes_keys();
  void add_nodes_keys(const std::string& value);
  void add_nodes_keys(std::string&& value);
  void add_nodes_keys(const char* value);
  void add_nodes_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nodes_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nodes_keys();
  private:
  const std::string& _internal_nodes_keys(int index) const;
  std::string* _internal_add_nodes_keys();
  public:

  // repeated bytes program_keys = 20;
  int program_keys_size() const;
  private:
  int _internal_program_keys_size() const;
  public:
  void clear_program_keys();
  const std::string& program_keys(int index) const;
  std::string* mutable_program_keys(int index);
  void set_program_keys(int index, const std::string& value);
  void set_program_keys(int index, std::string&& value);
  void set_program_keys(int index, const char* value);
  void set_program_keys(int index, const void* value, size_t size);
  std::string* add_program_keys();
  void add_program_keys(const std::string& value);
  void add_program_keys(std::string&& value);
  void add_program_keys(const char* value);
  void add_program_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& program_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_program_keys();
  private:
  const std::string& _internal_program_keys(int index) const;
  std::string* _internal_add_program_keys();
  public:

  // bytes new_state_root = 1;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // bytes new_acc_input_hash = 2;
  void clear_new_acc_input_hash();
  const std::string& new_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_new_acc_input_hash();
  void set_allocated_new_acc_input_hash(std::string* new_acc_input_hash);
  private:
  const std::string& _internal_new_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_new_acc_input_hash();
  public:

  // bytes new_local_exit_root = 3;
  void clear_new_local_exit_root();
  const std::string& new_local_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_local_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_local_exit_root();
  PROTOBUF_NODISCARD std::string* release_new_local_exit_root();
  void set_allocated_new_local_exit_root(std::string* new_local_exit_root);
  private:
  const std::string& _internal_new_local_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_local_exit_root(const std::string& value);
  std::string* _internal_mutable_new_local_exit_root();
  public:

  // string prover_id = 18;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 new_batch_num = 4;
  void clear_new_batch_num();
  uint64_t new_batch_num() const;
  void set_new_batch_num(uint64_t value);
  private:
  uint64_t _internal_new_batch_num() const;
  void _internal_set_new_batch_num(uint64_t value);
  public:

  // uint32 cnt_keccak_hashes = 5;
  void clear_cnt_keccak_hashes();
  uint32_t cnt_keccak_hashes() const;
  void set_cnt_keccak_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_keccak_hashes() const;
  void _internal_set_cnt_keccak_hashes(uint32_t value);
  public:

  // uint32 cnt_poseidon_hashes = 6;
  void clear_cnt_poseidon_hashes();
  uint32_t cnt_poseidon_hashes() const;
  void set_cnt_poseidon_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_poseidon_hashes() const;
  void _internal_set_cnt_poseidon_hashes(uint32_t value);
  public:

  // uint32 cnt_poseidon_paddings = 7;
  void clear_cnt_poseidon_paddings();
  uint32_t cnt_poseidon_paddings() const;
  void set_cnt_poseidon_paddings(uint32_t value);
  private:
  uint32_t _internal_cnt_poseidon_paddings() const;
  void _internal_set_cnt_poseidon_paddings(uint32_t value);
  public:

  // uint32 cnt_mem_aligns = 8;
  void clear_cnt_mem_aligns();
  uint32_t cnt_mem_aligns() const;
  void set_cnt_mem_aligns(uint32_t value);
  private:
  uint32_t _internal_cnt_mem_aligns() const;
  void _internal_set_cnt_mem_aligns(uint32_t value);
  public:

  // uint32 cnt_arithmetics = 9;
  void clear_cnt_arithmetics();
  uint32_t cnt_arithmetics() const;
  void set_cnt_arithmetics(uint32_t value);
  private:
  uint32_t _internal_cnt_arithmetics() const;
  void _internal_set_cnt_arithmetics(uint32_t value);
  public:

  // uint32 cnt_binaries = 10;
  void clear_cnt_binaries();
  uint32_t cnt_binaries() const;
  void set_cnt_binaries(uint32_t value);
  private:
  uint32_t _internal_cnt_binaries() const;
  void _internal_set_cnt_binaries(uint32_t value);
  public:

  // uint64 cumulative_gas_used = 12;
  void clear_cumulative_gas_used();
  uint64_t cumulative_gas_used() const;
  void set_cumulative_gas_used(uint64_t value);
  private:
  uint64_t _internal_cumulative_gas_used() const;
  void _internal_set_cumulative_gas_used(uint64_t value);
  public:

  // uint32 cnt_steps = 11;
  void clear_cnt_steps();
  uint32_t cnt_steps() const;
  void set_cnt_steps(uint32_t value);
  private:
  uint32_t _internal_cnt_steps() const;
  void _internal_set_cnt_steps(uint32_t value);
  public:

  // .executor.v1.ExecutorError error = 14;
  void clear_error();
  ::executor::v1::ExecutorError error() const;
  void set_error(::executor::v1::ExecutorError value);
  private:
  ::executor::v1::ExecutorError _internal_error() const;
  void _internal_set_error(::executor::v1::ExecutorError value);
  public:

  // uint64 flush_id = 16;
  void clear_flush_id();
  uint64_t flush_id() const;
  void set_flush_id(uint64_t value);
  private:
  uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(uint64_t value);
  public:

  // uint64 stored_flush_id = 17;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse > responses_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse,
        std::string, ::executor::v1::InfoReadWrite,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> read_write_addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nodes_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> program_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_local_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t new_batch_num_;
    uint32_t cnt_keccak_hashes_;
    uint32_t cnt_poseidon_hashes_;
    uint32_t cnt_poseidon_paddings_;
    uint32_t cnt_mem_aligns_;
    uint32_t cnt_arithmetics_;
    uint32_t cnt_binaries_;
    uint64_t cumulative_gas_used_;
    uint32_t cnt_steps_;
    int error_;
    uint64_t flush_id_;
    uint64_t stored_flush_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class GetFlushStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.GetFlushStatusResponse) */ {
 public:
  inline GetFlushStatusResponse() : GetFlushStatusResponse(nullptr) {}
  ~GetFlushStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushStatusResponse(const GetFlushStatusResponse& from);
  GetFlushStatusResponse(GetFlushStatusResponse&& from) noexcept
    : GetFlushStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushStatusResponse& operator=(const GetFlushStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushStatusResponse& operator=(GetFlushStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushStatusResponse*>(
               &_GetFlushStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetFlushStatusResponse& a, GetFlushStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushStatusResponse& from) {
    GetFlushStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.GetFlushStatusResponse";
  }
  protected:
  explicit GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProverIdFieldNumber = 8,
    kStoredFlushIdFieldNumber = 1,
    kStoringFlushIdFieldNumber = 2,
    kLastFlushIdFieldNumber = 3,
    kPendingToFlushNodesFieldNumber = 4,
    kPendingToFlushProgramFieldNumber = 5,
    kStoringNodesFieldNumber = 6,
    kStoringProgramFieldNumber = 7,
  };
  // string prover_id = 8;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // uint64 storing_flush_id = 2;
  void clear_storing_flush_id();
  uint64_t storing_flush_id() const;
  void set_storing_flush_id(uint64_t value);
  private:
  uint64_t _internal_storing_flush_id() const;
  void _internal_set_storing_flush_id(uint64_t value);
  public:

  // uint64 last_flush_id = 3;
  void clear_last_flush_id();
  uint64_t last_flush_id() const;
  void set_last_flush_id(uint64_t value);
  private:
  uint64_t _internal_last_flush_id() const;
  void _internal_set_last_flush_id(uint64_t value);
  public:

  // uint64 pending_to_flush_nodes = 4;
  void clear_pending_to_flush_nodes();
  uint64_t pending_to_flush_nodes() const;
  void set_pending_to_flush_nodes(uint64_t value);
  private:
  uint64_t _internal_pending_to_flush_nodes() const;
  void _internal_set_pending_to_flush_nodes(uint64_t value);
  public:

  // uint64 pending_to_flush_program = 5;
  void clear_pending_to_flush_program();
  uint64_t pending_to_flush_program() const;
  void set_pending_to_flush_program(uint64_t value);
  private:
  uint64_t _internal_pending_to_flush_program() const;
  void _internal_set_pending_to_flush_program(uint64_t value);
  public:

  // uint64 storing_nodes = 6;
  void clear_storing_nodes();
  uint64_t storing_nodes() const;
  void set_storing_nodes(uint64_t value);
  private:
  uint64_t _internal_storing_nodes() const;
  void _internal_set_storing_nodes(uint64_t value);
  public:

  // uint64 storing_program = 7;
  void clear_storing_program();
  uint64_t storing_program() const;
  void set_storing_program(uint64_t value);
  private:
  uint64_t _internal_storing_program() const;
  void _internal_set_storing_program(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.GetFlushStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t stored_flush_id_;
    uint64_t storing_flush_id_;
    uint64_t last_flush_id_;
    uint64_t pending_to_flush_nodes_;
    uint64_t pending_to_flush_program_;
    uint64_t storing_nodes_;
    uint64_t storing_program_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TraceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TraceConfig) */ {
 public:
  inline TraceConfig() : TraceConfig(nullptr) {}
  ~TraceConfig() override;
  explicit PROTOBUF_CONSTEXPR TraceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceConfig(const TraceConfig& from);
  TraceConfig(TraceConfig&& from) noexcept
    : TraceConfig() {
    *this = ::std::move(from);
  }

  inline TraceConfig& operator=(const TraceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceConfig& operator=(TraceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceConfig* internal_default_instance() {
    return reinterpret_cast<const TraceConfig*>(
               &_TraceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TraceConfig& a, TraceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceConfig& from) {
    TraceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TraceConfig";
  }
  protected:
  explicit TraceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashToGenerateExecuteTraceFieldNumber = 5,
    kTxHashToGenerateCallTraceFieldNumber = 6,
    kDisableStorageFieldNumber = 1,
    kDisableStackFieldNumber = 2,
    kEnableMemoryFieldNumber = 3,
    kEnableReturnDataFieldNumber = 4,
  };
  // bytes tx_hash_to_generate_execute_trace = 5;
  void clear_tx_hash_to_generate_execute_trace();
  const std::string& tx_hash_to_generate_execute_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash_to_generate_execute_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash_to_generate_execute_trace();
  PROTOBUF_NODISCARD std::string* release_tx_hash_to_generate_execute_trace();
  void set_allocated_tx_hash_to_generate_execute_trace(std::string* tx_hash_to_generate_execute_trace);
  private:
  const std::string& _internal_tx_hash_to_generate_execute_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash_to_generate_execute_trace(const std::string& value);
  std::string* _internal_mutable_tx_hash_to_generate_execute_trace();
  public:

  // bytes tx_hash_to_generate_call_trace = 6;
  void clear_tx_hash_to_generate_call_trace();
  const std::string& tx_hash_to_generate_call_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash_to_generate_call_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash_to_generate_call_trace();
  PROTOBUF_NODISCARD std::string* release_tx_hash_to_generate_call_trace();
  void set_allocated_tx_hash_to_generate_call_trace(std::string* tx_hash_to_generate_call_trace);
  private:
  const std::string& _internal_tx_hash_to_generate_call_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash_to_generate_call_trace(const std::string& value);
  std::string* _internal_mutable_tx_hash_to_generate_call_trace();
  public:

  // uint32 disable_storage = 1;
  void clear_disable_storage();
  uint32_t disable_storage() const;
  void set_disable_storage(uint32_t value);
  private:
  uint32_t _internal_disable_storage() const;
  void _internal_set_disable_storage(uint32_t value);
  public:

  // uint32 disable_stack = 2;
  void clear_disable_stack();
  uint32_t disable_stack() const;
  void set_disable_stack(uint32_t value);
  private:
  uint32_t _internal_disable_stack() const;
  void _internal_set_disable_stack(uint32_t value);
  public:

  // uint32 enable_memory = 3;
  void clear_enable_memory();
  uint32_t enable_memory() const;
  void set_enable_memory(uint32_t value);
  private:
  uint32_t _internal_enable_memory() const;
  void _internal_set_enable_memory(uint32_t value);
  public:

  // uint32 enable_return_data = 4;
  void clear_enable_return_data();
  uint32_t enable_return_data() const;
  void set_enable_return_data(uint32_t value);
  private:
  uint32_t _internal_enable_return_data() const;
  void _internal_set_enable_return_data(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TraceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_to_generate_execute_trace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_to_generate_call_trace_;
    uint32_t disable_storage_;
    uint32_t disable_stack_;
    uint32_t enable_memory_;
    uint32_t enable_return_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class InfoReadWrite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.InfoReadWrite) */ {
 public:
  inline InfoReadWrite() : InfoReadWrite(nullptr) {}
  ~InfoReadWrite() override;
  explicit PROTOBUF_CONSTEXPR InfoReadWrite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoReadWrite(const InfoReadWrite& from);
  InfoReadWrite(InfoReadWrite&& from) noexcept
    : InfoReadWrite() {
    *this = ::std::move(from);
  }

  inline InfoReadWrite& operator=(const InfoReadWrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoReadWrite& operator=(InfoReadWrite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoReadWrite& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoReadWrite* internal_default_instance() {
    return reinterpret_cast<const InfoReadWrite*>(
               &_InfoReadWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InfoReadWrite& a, InfoReadWrite& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoReadWrite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoReadWrite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoReadWrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoReadWrite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InfoReadWrite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InfoReadWrite& from) {
    InfoReadWrite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoReadWrite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.InfoReadWrite";
  }
  protected:
  explicit InfoReadWrite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kBalanceFieldNumber = 2,
  };
  // string nonce = 1;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // string balance = 2;
  void clear_balance();
  const std::string& balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.InfoReadWrite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class CallTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.CallTrace) */ {
 public:
  inline CallTrace() : CallTrace(nullptr) {}
  ~CallTrace() override;
  explicit PROTOBUF_CONSTEXPR CallTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallTrace(const CallTrace& from);
  CallTrace(CallTrace&& from) noexcept
    : CallTrace() {
    *this = ::std::move(from);
  }

  inline CallTrace& operator=(const CallTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallTrace& operator=(CallTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallTrace* internal_default_instance() {
    return reinterpret_cast<const CallTrace*>(
               &_CallTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CallTrace& a, CallTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(CallTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallTrace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallTrace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallTrace& from) {
    CallTrace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.CallTrace";
  }
  protected:
  explicit CallTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepsFieldNumber = 2,
    kContextFieldNumber = 1,
  };
  // repeated .executor.v1.TransactionStep steps = 2;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::executor::v1::TransactionStep* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >*
      mutable_steps();
  private:
  const ::executor::v1::TransactionStep& _internal_steps(int index) const;
  ::executor::v1::TransactionStep* _internal_add_steps();
  public:
  const ::executor::v1::TransactionStep& steps(int index) const;
  ::executor::v1::TransactionStep* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >&
      steps() const;

  // .executor.v1.TransactionContext context = 1;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::executor::v1::TransactionContext& context() const;
  PROTOBUF_NODISCARD ::executor::v1::TransactionContext* release_context();
  ::executor::v1::TransactionContext* mutable_context();
  void set_allocated_context(::executor::v1::TransactionContext* context);
  private:
  const ::executor::v1::TransactionContext& _internal_context() const;
  ::executor::v1::TransactionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::executor::v1::TransactionContext* context);
  ::executor::v1::TransactionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:executor.v1.CallTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep > steps_;
    ::executor::v1::TransactionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TransactionContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TransactionContext) */ {
 public:
  inline TransactionContext() : TransactionContext(nullptr) {}
  ~TransactionContext() override;
  explicit PROTOBUF_CONSTEXPR TransactionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionContext(const TransactionContext& from);
  TransactionContext(TransactionContext&& from) noexcept
    : TransactionContext() {
    *this = ::std::move(from);
  }

  inline TransactionContext& operator=(const TransactionContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionContext& operator=(TransactionContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionContext* internal_default_instance() {
    return reinterpret_cast<const TransactionContext*>(
               &_TransactionContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TransactionContext& a, TransactionContext& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionContext& from) {
    TransactionContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TransactionContext";
  }
  protected:
  explicit TransactionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kDataFieldNumber = 4,
    kValueFieldNumber = 6,
    kBatchFieldNumber = 7,
    kOutputFieldNumber = 8,
    kGasPriceFieldNumber = 10,
    kOldStateRootFieldNumber = 12,
    kGasFieldNumber = 5,
    kGasUsedFieldNumber = 9,
    kExecutionTimeFieldNumber = 11,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string from = 2;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 3;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string value = 6;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes batch = 7;
  void clear_batch();
  const std::string& batch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch();
  PROTOBUF_NODISCARD std::string* release_batch();
  void set_allocated_batch(std::string* batch);
  private:
  const std::string& _internal_batch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch(const std::string& value);
  std::string* _internal_mutable_batch();
  public:

  // bytes output = 8;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // string gas_price = 10;
  void clear_gas_price();
  const std::string& gas_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gas_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gas_price();
  PROTOBUF_NODISCARD std::string* release_gas_price();
  void set_allocated_gas_price(std::string* gas_price);
  private:
  const std::string& _internal_gas_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gas_price(const std::string& value);
  std::string* _internal_mutable_gas_price();
  public:

  // bytes old_state_root = 12;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // uint64 gas = 5;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // uint64 gas_used = 9;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint32 execution_time = 11;
  void clear_execution_time();
  uint32_t execution_time() const;
  void set_execution_time(uint32_t value);
  private:
  uint32_t _internal_execution_time() const;
  void _internal_set_execution_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TransactionContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gas_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    uint64_t gas_;
    uint64_t gas_used_;
    uint32_t execution_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TransactionStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TransactionStep) */ {
 public:
  inline TransactionStep() : TransactionStep(nullptr) {}
  ~TransactionStep() override;
  explicit PROTOBUF_CONSTEXPR TransactionStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionStep(const TransactionStep& from);
  TransactionStep(TransactionStep&& from) noexcept
    : TransactionStep() {
    *this = ::std::move(from);
  }

  inline TransactionStep& operator=(const TransactionStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionStep& operator=(TransactionStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionStep* internal_default_instance() {
    return reinterpret_cast<const TransactionStep*>(
               &_TransactionStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TransactionStep& a, TransactionStep& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionStep& from) {
    TransactionStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TransactionStep";
  }
  protected:
  explicit TransactionStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStackFieldNumber = 8,
    kStateRootFieldNumber = 1,
    kMemoryFieldNumber = 9,
    kReturnDataFieldNumber = 12,
    kContractFieldNumber = 13,
    kPcFieldNumber = 3,
    kGasFieldNumber = 4,
    kDepthFieldNumber = 2,
    kOpFieldNumber = 7,
    kGasCostFieldNumber = 5,
    kGasRefundFieldNumber = 6,
    kMemorySizeFieldNumber = 10,
    kMemoryOffsetFieldNumber = 11,
    kErrorFieldNumber = 14,
  };
  // repeated string stack = 8;
  int stack_size() const;
  private:
  int _internal_stack_size() const;
  public:
  void clear_stack();
  const std::string& stack(int index) const;
  std::string* mutable_stack(int index);
  void set_stack(int index, const std::string& value);
  void set_stack(int index, std::string&& value);
  void set_stack(int index, const char* value);
  void set_stack(int index, const char* value, size_t size);
  std::string* add_stack();
  void add_stack(const std::string& value);
  void add_stack(std::string&& value);
  void add_stack(const char* value);
  void add_stack(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stack() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stack();
  private:
  const std::string& _internal_stack(int index) const;
  std::string* _internal_add_stack();
  public:

  // bytes state_root = 1;
  void clear_state_root();
  const std::string& state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_root();
  PROTOBUF_NODISCARD std::string* release_state_root();
  void set_allocated_state_root(std::string* state_root);
  private:
  const std::string& _internal_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_root(const std::string& value);
  std::string* _internal_mutable_state_root();
  public:

  // bytes memory = 9;
  void clear_memory();
  const std::string& memory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory();
  PROTOBUF_NODISCARD std::string* release_memory();
  void set_allocated_memory(std::string* memory);
  private:
  const std::string& _internal_memory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory(const std::string& value);
  std::string* _internal_mutable_memory();
  public:

  // bytes return_data = 12;
  void clear_return_data();
  const std::string& return_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_data();
  PROTOBUF_NODISCARD std::string* release_return_data();
  void set_allocated_return_data(std::string* return_data);
  private:
  const std::string& _internal_return_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_data(const std::string& value);
  std::string* _internal_mutable_return_data();
  public:

  // .executor.v1.Contract contract = 13;
  bool has_contract() const;
  private:
  bool _internal_has_contract() const;
  public:
  void clear_contract();
  const ::executor::v1::Contract& contract() const;
  PROTOBUF_NODISCARD ::executor::v1::Contract* release_contract();
  ::executor::v1::Contract* mutable_contract();
  void set_allocated_contract(::executor::v1::Contract* contract);
  private:
  const ::executor::v1::Contract& _internal_contract() const;
  ::executor::v1::Contract* _internal_mutable_contract();
  public:
  void unsafe_arena_set_allocated_contract(
      ::executor::v1::Contract* contract);
  ::executor::v1::Contract* unsafe_arena_release_contract();

  // uint64 pc = 3;
  void clear_pc();
  uint64_t pc() const;
  void set_pc(uint64_t value);
  private:
  uint64_t _internal_pc() const;
  void _internal_set_pc(uint64_t value);
  public:

  // uint64 gas = 4;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // uint32 depth = 2;
  void clear_depth();
  uint32_t depth() const;
  void set_depth(uint32_t value);
  private:
  uint32_t _internal_depth() const;
  void _internal_set_depth(uint32_t value);
  public:

  // uint32 op = 7;
  void clear_op();
  uint32_t op() const;
  void set_op(uint32_t value);
  private:
  uint32_t _internal_op() const;
  void _internal_set_op(uint32_t value);
  public:

  // uint64 gas_cost = 5;
  void clear_gas_cost();
  uint64_t gas_cost() const;
  void set_gas_cost(uint64_t value);
  private:
  uint64_t _internal_gas_cost() const;
  void _internal_set_gas_cost(uint64_t value);
  public:

  // uint64 gas_refund = 6;
  void clear_gas_refund();
  uint64_t gas_refund() const;
  void set_gas_refund(uint64_t value);
  private:
  uint64_t _internal_gas_refund() const;
  void _internal_set_gas_refund(uint64_t value);
  public:

  // uint32 memory_size = 10;
  void clear_memory_size();
  uint32_t memory_size() const;
  void set_memory_size(uint32_t value);
  private:
  uint32_t _internal_memory_size() const;
  void _internal_set_memory_size(uint32_t value);
  public:

  // uint32 memory_offset = 11;
  void clear_memory_offset();
  uint32_t memory_offset() const;
  void set_memory_offset(uint32_t value);
  private:
  uint32_t _internal_memory_offset() const;
  void _internal_set_memory_offset(uint32_t value);
  public:

  // .executor.v1.RomError error = 14;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TransactionStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stack_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_data_;
    ::executor::v1::Contract* contract_;
    uint64_t pc_;
    uint64_t gas_;
    uint32_t depth_;
    uint32_t op_;
    uint64_t gas_cost_;
    uint64_t gas_refund_;
    uint32_t memory_size_;
    uint32_t memory_offset_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.Contract) */ {
 public:
  inline Contract() : Contract(nullptr) {}
  ~Contract() override;
  explicit PROTOBUF_CONSTEXPR Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contract(const Contract& from);
  Contract(Contract&& from) noexcept
    : Contract() {
    *this = ::std::move(from);
  }

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contract& operator=(Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
               &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Contract& a, Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Contract& from) {
    Contract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.Contract";
  }
  protected:
  explicit Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kCallerFieldNumber = 2,
    kValueFieldNumber = 3,
    kDataFieldNumber = 4,
    kTypeFieldNumber = 6,
    kGasFieldNumber = 5,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string caller = 2;
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_NODISCARD std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string type = 6;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint64 gas = 5;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    uint64_t gas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessTransactionResponse) */ {
 public:
  inline ProcessTransactionResponse() : ProcessTransactionResponse(nullptr) {}
  ~ProcessTransactionResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessTransactionResponse(const ProcessTransactionResponse& from);
  ProcessTransactionResponse(ProcessTransactionResponse&& from) noexcept
    : ProcessTransactionResponse() {
    *this = ::std::move(from);
  }

  inline ProcessTransactionResponse& operator=(const ProcessTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTransactionResponse& operator=(ProcessTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessTransactionResponse*>(
               &_ProcessTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ProcessTransactionResponse& a, ProcessTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessTransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessTransactionResponse& from) {
    ProcessTransactionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTransactionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessTransactionResponse";
  }
  protected:
  explicit ProcessTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 11,
    kExecutionTraceFieldNumber = 13,
    kTxHashFieldNumber = 1,
    kRlpTxFieldNumber = 2,
    kReturnValueFieldNumber = 4,
    kCreateAddressFieldNumber = 9,
    kStateRootFieldNumber = 10,
    kEffectiveGasPriceFieldNumber = 15,
    kCallTraceFieldNumber = 14,
    kGasLeftFieldNumber = 5,
    kTypeFieldNumber = 3,
    kErrorFieldNumber = 8,
    kGasUsedFieldNumber = 6,
    kGasRefundedFieldNumber = 7,
    kEffectivePercentageFieldNumber = 16,
    kHasGaspriceOpcodeFieldNumber = 17,
    kHasBalanceOpcodeFieldNumber = 18,
  };
  // repeated .executor.v1.Log logs = 11;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::executor::v1::Log* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >*
      mutable_logs();
  private:
  const ::executor::v1::Log& _internal_logs(int index) const;
  ::executor::v1::Log* _internal_add_logs();
  public:
  const ::executor::v1::Log& logs(int index) const;
  ::executor::v1::Log* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >&
      logs() const;

  // repeated .executor.v1.ExecutionTraceStep execution_trace = 13;
  int execution_trace_size() const;
  private:
  int _internal_execution_trace_size() const;
  public:
  void clear_execution_trace();
  ::executor::v1::ExecutionTraceStep* mutable_execution_trace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ExecutionTraceStep >*
      mutable_execution_trace();
  private:
  const ::executor::v1::ExecutionTraceStep& _internal_execution_trace(int index) const;
  ::executor::v1::ExecutionTraceStep* _internal_add_execution_trace();
  public:
  const ::executor::v1::ExecutionTraceStep& execution_trace(int index) const;
  ::executor::v1::ExecutionTraceStep* add_execution_trace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ExecutionTraceStep >&
      execution_trace() const;

  // bytes tx_hash = 1;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes rlp_tx = 2;
  void clear_rlp_tx();
  const std::string& rlp_tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlp_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlp_tx();
  PROTOBUF_NODISCARD std::string* release_rlp_tx();
  void set_allocated_rlp_tx(std::string* rlp_tx);
  private:
  const std::string& _internal_rlp_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlp_tx(const std::string& value);
  std::string* _internal_mutable_rlp_tx();
  public:

  // bytes return_value = 4;
  void clear_return_value();
  const std::string& return_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_value();
  PROTOBUF_NODISCARD std::string* release_return_value();
  void set_allocated_return_value(std::string* return_value);
  private:
  const std::string& _internal_return_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_value(const std::string& value);
  std::string* _internal_mutable_return_value();
  public:

  // string create_address = 9;
  void clear_create_address();
  const std::string& create_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_address();
  PROTOBUF_NODISCARD std::string* release_create_address();
  void set_allocated_create_address(std::string* create_address);
  private:
  const std::string& _internal_create_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_address(const std::string& value);
  std::string* _internal_mutable_create_address();
  public:

  // bytes state_root = 10;
  void clear_state_root();
  const std::string& state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_root();
  PROTOBUF_NODISCARD std::string* release_state_root();
  void set_allocated_state_root(std::string* state_root);
  private:
  const std::string& _internal_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_root(const std::string& value);
  std::string* _internal_mutable_state_root();
  public:

  // string effective_gas_price = 15;
  void clear_effective_gas_price();
  const std::string& effective_gas_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_effective_gas_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_effective_gas_price();
  PROTOBUF_NODISCARD std::string* release_effective_gas_price();
  void set_allocated_effective_gas_price(std::string* effective_gas_price);
  private:
  const std::string& _internal_effective_gas_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effective_gas_price(const std::string& value);
  std::string* _internal_mutable_effective_gas_price();
  public:

  // .executor.v1.CallTrace call_trace = 14;
  bool has_call_trace() const;
  private:
  bool _internal_has_call_trace() const;
  public:
  void clear_call_trace();
  const ::executor::v1::CallTrace& call_trace() const;
  PROTOBUF_NODISCARD ::executor::v1::CallTrace* release_call_trace();
  ::executor::v1::CallTrace* mutable_call_trace();
  void set_allocated_call_trace(::executor::v1::CallTrace* call_trace);
  private:
  const ::executor::v1::CallTrace& _internal_call_trace() const;
  ::executor::v1::CallTrace* _internal_mutable_call_trace();
  public:
  void unsafe_arena_set_allocated_call_trace(
      ::executor::v1::CallTrace* call_trace);
  ::executor::v1::CallTrace* unsafe_arena_release_call_trace();

  // uint64 gas_left = 5;
  void clear_gas_left();
  uint64_t gas_left() const;
  void set_gas_left(uint64_t value);
  private:
  uint64_t _internal_gas_left() const;
  void _internal_set_gas_left(uint64_t value);
  public:

  // uint32 type = 3;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .executor.v1.RomError error = 8;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // uint64 gas_used = 6;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint64 gas_refunded = 7;
  void clear_gas_refunded();
  uint64_t gas_refunded() const;
  void set_gas_refunded(uint64_t value);
  private:
  uint64_t _internal_gas_refunded() const;
  void _internal_set_gas_refunded(uint64_t value);
  public:

  // uint32 effective_percentage = 16;
  void clear_effective_percentage();
  uint32_t effective_percentage() const;
  void set_effective_percentage(uint32_t value);
  private:
  uint32_t _internal_effective_percentage() const;
  void _internal_set_effective_percentage(uint32_t value);
  public:

  // uint32 has_gasprice_opcode = 17;
  void clear_has_gasprice_opcode();
  uint32_t has_gasprice_opcode() const;
  void set_has_gasprice_opcode(uint32_t value);
  private:
  uint32_t _internal_has_gasprice_opcode() const;
  void _internal_set_has_gasprice_opcode(uint32_t value);
  public:

  // uint32 has_balance_opcode = 18;
  void clear_has_balance_opcode();
  uint32_t has_balance_opcode() const;
  void set_has_balance_opcode(uint32_t value);
  private:
  uint32_t _internal_has_balance_opcode() const;
  void _internal_set_has_balance_opcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log > logs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ExecutionTraceStep > execution_trace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlp_tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr effective_gas_price_;
    ::executor::v1::CallTrace* call_trace_;
    uint64_t gas_left_;
    uint32_t type_;
    int error_;
    uint64_t gas_used_;
    uint64_t gas_refunded_;
    uint32_t effective_percentage_;
    uint32_t has_gasprice_opcode_;
    uint32_t has_balance_opcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 2,
    kAddressFieldNumber = 1,
    kDataFieldNumber = 3,
    kTxHashFieldNumber = 5,
    kBatchHashFieldNumber = 7,
    kBatchNumberFieldNumber = 4,
    kTxIndexFieldNumber = 6,
    kIndexFieldNumber = 8,
  };
  // repeated bytes topics = 2;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const void* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes tx_hash = 5;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes batch_hash = 7;
  void clear_batch_hash();
  const std::string& batch_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_hash();
  PROTOBUF_NODISCARD std::string* release_batch_hash();
  void set_allocated_batch_hash(std::string* batch_hash);
  private:
  const std::string& _internal_batch_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_hash(const std::string& value);
  std::string* _internal_mutable_batch_hash();
  public:

  // uint64 batch_number = 4;
  void clear_batch_number();
  uint64_t batch_number() const;
  void set_batch_number(uint64_t value);
  private:
  uint64_t _internal_batch_number() const;
  void _internal_set_batch_number(uint64_t value);
  public:

  // uint32 tx_index = 6;
  void clear_tx_index();
  uint32_t tx_index() const;
  void set_tx_index(uint32_t value);
  private:
  uint32_t _internal_tx_index() const;
  void _internal_set_tx_index(uint32_t value);
  public:

  // uint32 index = 8;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_hash_;
    uint64_t batch_number_;
    uint32_t tx_index_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ExecutionTraceStep_StorageEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecutionTraceStep_StorageEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecutionTraceStep_StorageEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ExecutionTraceStep_StorageEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ExecutionTraceStep_StorageEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExecutionTraceStep_StorageEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExecutionTraceStep_StorageEntry_DoNotUse& other);
  static const ExecutionTraceStep_StorageEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecutionTraceStep_StorageEntry_DoNotUse*>(&_ExecutionTraceStep_StorageEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ExecutionTraceStep.StorageEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ExecutionTraceStep.StorageEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ExecutionTraceStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ExecutionTraceStep) */ {
 public:
  inline ExecutionTraceStep() : ExecutionTraceStep(nullptr) {}
  ~ExecutionTraceStep() override;
  explicit PROTOBUF_CONSTEXPR ExecutionTraceStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionTraceStep(const ExecutionTraceStep& from);
  ExecutionTraceStep(ExecutionTraceStep&& from) noexcept
    : ExecutionTraceStep() {
    *this = ::std::move(from);
  }

  inline ExecutionTraceStep& operator=(const ExecutionTraceStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionTraceStep& operator=(ExecutionTraceStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionTraceStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionTraceStep* internal_default_instance() {
    return reinterpret_cast<const ExecutionTraceStep*>(
               &_ExecutionTraceStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExecutionTraceStep& a, ExecutionTraceStep& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionTraceStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionTraceStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionTraceStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionTraceStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionTraceStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionTraceStep& from) {
    ExecutionTraceStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionTraceStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ExecutionTraceStep";
  }
  protected:
  explicit ExecutionTraceStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStackFieldNumber = 8,
    kStorageFieldNumber = 10,
    kOpFieldNumber = 2,
    kMemoryFieldNumber = 5,
    kReturnDataFieldNumber = 9,
    kPcFieldNumber = 1,
    kRemainingGasFieldNumber = 3,
    kGasCostFieldNumber = 4,
    kMemorySizeFieldNumber = 6,
    kMemoryOffsetFieldNumber = 7,
    kGasRefundFieldNumber = 12,
    kDepthFieldNumber = 11,
    kErrorFieldNumber = 13,
  };
  // repeated string stack = 8;
  int stack_size() const;
  private:
  int _internal_stack_size() const;
  public:
  void clear_stack();
  const std::string& stack(int index) const;
  std::string* mutable_stack(int index);
  void set_stack(int index, const std::string& value);
  void set_stack(int index, std::string&& value);
  void set_stack(int index, const char* value);
  void set_stack(int index, const char* value, size_t size);
  std::string* add_stack();
  void add_stack(const std::string& value);
  void add_stack(std::string&& value);
  void add_stack(const char* value);
  void add_stack(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stack() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stack();
  private:
  const std::string& _internal_stack(int index) const;
  std::string* _internal_add_stack();
  public:

  // map<string, string> storage = 10;
  int storage_size() const;
  private:
  int _internal_storage_size() const;
  public:
  void clear_storage();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_storage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_storage();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      storage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_storage();

  // string op = 2;
  void clear_op();
  const std::string& op() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op();
  PROTOBUF_NODISCARD std::string* release_op();
  void set_allocated_op(std::string* op);
  private:
  const std::string& _internal_op() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op(const std::string& value);
  std::string* _internal_mutable_op();
  public:

  // bytes memory = 5;
  void clear_memory();
  const std::string& memory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory();
  PROTOBUF_NODISCARD std::string* release_memory();
  void set_allocated_memory(std::string* memory);
  private:
  const std::string& _internal_memory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory(const std::string& value);
  std::string* _internal_mutable_memory();
  public:

  // bytes return_data = 9;
  void clear_return_data();
  const std::string& return_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_data();
  PROTOBUF_NODISCARD std::string* release_return_data();
  void set_allocated_return_data(std::string* return_data);
  private:
  const std::string& _internal_return_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_data(const std::string& value);
  std::string* _internal_mutable_return_data();
  public:

  // uint64 pc = 1;
  void clear_pc();
  uint64_t pc() const;
  void set_pc(uint64_t value);
  private:
  uint64_t _internal_pc() const;
  void _internal_set_pc(uint64_t value);
  public:

  // uint64 remaining_gas = 3;
  void clear_remaining_gas();
  uint64_t remaining_gas() const;
  void set_remaining_gas(uint64_t value);
  private:
  uint64_t _internal_remaining_gas() const;
  void _internal_set_remaining_gas(uint64_t value);
  public:

  // uint64 gas_cost = 4;
  void clear_gas_cost();
  uint64_t gas_cost() const;
  void set_gas_cost(uint64_t value);
  private:
  uint64_t _internal_gas_cost() const;
  void _internal_set_gas_cost(uint64_t value);
  public:

  // uint32 memory_size = 6;
  void clear_memory_size();
  uint32_t memory_size() const;
  void set_memory_size(uint32_t value);
  private:
  uint32_t _internal_memory_size() const;
  void _internal_set_memory_size(uint32_t value);
  public:

  // uint32 memory_offset = 7;
  void clear_memory_offset();
  uint32_t memory_offset() const;
  void set_memory_offset(uint32_t value);
  private:
  uint32_t _internal_memory_offset() const;
  void _internal_set_memory_offset(uint32_t value);
  public:

  // uint64 gas_refund = 12;
  void clear_gas_refund();
  uint64_t gas_refund() const;
  void set_gas_refund(uint64_t value);
  private:
  uint64_t _internal_gas_refund() const;
  void _internal_set_gas_refund(uint64_t value);
  public:

  // uint32 depth = 11;
  void clear_depth();
  uint32_t depth() const;
  void set_depth(uint32_t value);
  private:
  uint32_t _internal_depth() const;
  void _internal_set_depth(uint32_t value);
  public:

  // .executor.v1.RomError error = 13;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ExecutionTraceStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stack_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ExecutionTraceStep_StorageEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> storage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_data_;
    uint64_t pc_;
    uint64_t remaining_gas_;
    uint64_t gas_cost_;
    uint32_t memory_size_;
    uint32_t memory_offset_;
    uint64_t gas_refund_;
    uint32_t depth_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessBatchRequest

// bytes old_state_root = 1;
inline void ProcessBatchRequest::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::old_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.old_state_root)
}
inline std::string* ProcessBatchRequest::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.old_state_root)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void ProcessBatchRequest::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_old_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void ProcessBatchRequest::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.old_state_root)
}

// bytes old_acc_input_hash = 2;
inline void ProcessBatchRequest::clear_old_acc_input_hash() {
  _impl_.old_acc_input_hash_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::old_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.old_acc_input_hash)
  return _internal_old_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_old_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.old_acc_input_hash)
}
inline std::string* ProcessBatchRequest::mutable_old_acc_input_hash() {
  std::string* _s = _internal_mutable_old_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.old_acc_input_hash)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_old_acc_input_hash() const {
  return _impl_.old_acc_input_hash_.Get();
}
inline void ProcessBatchRequest::_internal_set_old_acc_input_hash(const std::string& value) {
  
  _impl_.old_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_old_acc_input_hash() {
  
  return _impl_.old_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_old_acc_input_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.old_acc_input_hash)
  return _impl_.old_acc_input_hash_.Release();
}
inline void ProcessBatchRequest::set_allocated_old_acc_input_hash(std::string* old_acc_input_hash) {
  if (old_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.old_acc_input_hash_.SetAllocated(old_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_acc_input_hash_.IsDefault()) {
    _impl_.old_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.old_acc_input_hash)
}

// uint64 old_batch_num = 3;
inline void ProcessBatchRequest::clear_old_batch_num() {
  _impl_.old_batch_num_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_old_batch_num() const {
  return _impl_.old_batch_num_;
}
inline uint64_t ProcessBatchRequest::old_batch_num() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.old_batch_num)
  return _internal_old_batch_num();
}
inline void ProcessBatchRequest::_internal_set_old_batch_num(uint64_t value) {
  
  _impl_.old_batch_num_ = value;
}
inline void ProcessBatchRequest::set_old_batch_num(uint64_t value) {
  _internal_set_old_batch_num(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.old_batch_num)
}

// uint64 chain_id = 4;
inline void ProcessBatchRequest::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t ProcessBatchRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.chain_id)
  return _internal_chain_id();
}
inline void ProcessBatchRequest::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void ProcessBatchRequest::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.chain_id)
}

// uint64 fork_id = 5;
inline void ProcessBatchRequest::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t ProcessBatchRequest::fork_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.fork_id)
  return _internal_fork_id();
}
inline void ProcessBatchRequest::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void ProcessBatchRequest::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.fork_id)
}

// bytes batch_l2_data = 6;
inline void ProcessBatchRequest::clear_batch_l2_data() {
  _impl_.batch_l2_data_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::batch_l2_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.batch_l2_data)
  return _internal_batch_l2_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_batch_l2_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_l2_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.batch_l2_data)
}
inline std::string* ProcessBatchRequest::mutable_batch_l2_data() {
  std::string* _s = _internal_mutable_batch_l2_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.batch_l2_data)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_batch_l2_data() const {
  return _impl_.batch_l2_data_.Get();
}
inline void ProcessBatchRequest::_internal_set_batch_l2_data(const std::string& value) {
  
  _impl_.batch_l2_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_batch_l2_data() {
  
  return _impl_.batch_l2_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_batch_l2_data() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.batch_l2_data)
  return _impl_.batch_l2_data_.Release();
}
inline void ProcessBatchRequest::set_allocated_batch_l2_data(std::string* batch_l2_data) {
  if (batch_l2_data != nullptr) {
    
  } else {
    
  }
  _impl_.batch_l2_data_.SetAllocated(batch_l2_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_l2_data_.IsDefault()) {
    _impl_.batch_l2_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.batch_l2_data)
}

// bytes global_exit_root = 7;
inline void ProcessBatchRequest::clear_global_exit_root() {
  _impl_.global_exit_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::global_exit_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.global_exit_root)
  return _internal_global_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_global_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.global_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.global_exit_root)
}
inline std::string* ProcessBatchRequest::mutable_global_exit_root() {
  std::string* _s = _internal_mutable_global_exit_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.global_exit_root)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_global_exit_root() const {
  return _impl_.global_exit_root_.Get();
}
inline void ProcessBatchRequest::_internal_set_global_exit_root(const std::string& value) {
  
  _impl_.global_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_global_exit_root() {
  
  return _impl_.global_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_global_exit_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.global_exit_root)
  return _impl_.global_exit_root_.Release();
}
inline void ProcessBatchRequest::set_allocated_global_exit_root(std::string* global_exit_root) {
  if (global_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.global_exit_root_.SetAllocated(global_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.global_exit_root_.IsDefault()) {
    _impl_.global_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.global_exit_root)
}

// uint64 eth_timestamp = 8;
inline void ProcessBatchRequest::clear_eth_timestamp() {
  _impl_.eth_timestamp_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_eth_timestamp() const {
  return _impl_.eth_timestamp_;
}
inline uint64_t ProcessBatchRequest::eth_timestamp() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.eth_timestamp)
  return _internal_eth_timestamp();
}
inline void ProcessBatchRequest::_internal_set_eth_timestamp(uint64_t value) {
  
  _impl_.eth_timestamp_ = value;
}
inline void ProcessBatchRequest::set_eth_timestamp(uint64_t value) {
  _internal_set_eth_timestamp(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.eth_timestamp)
}

// string coinbase = 9;
inline void ProcessBatchRequest::clear_coinbase() {
  _impl_.coinbase_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::coinbase() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.coinbase)
  return _internal_coinbase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_coinbase(ArgT0&& arg0, ArgT... args) {
 
 _impl_.coinbase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.coinbase)
}
inline std::string* ProcessBatchRequest::mutable_coinbase() {
  std::string* _s = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.coinbase)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_coinbase() const {
  return _impl_.coinbase_.Get();
}
inline void ProcessBatchRequest::_internal_set_coinbase(const std::string& value) {
  
  _impl_.coinbase_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_coinbase() {
  
  return _impl_.coinbase_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_coinbase() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.coinbase)
  return _impl_.coinbase_.Release();
}
inline void ProcessBatchRequest::set_allocated_coinbase(std::string* coinbase) {
  if (coinbase != nullptr) {
    
  } else {
    
  }
  _impl_.coinbase_.SetAllocated(coinbase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coinbase_.IsDefault()) {
    _impl_.coinbase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.coinbase)
}

// uint32 update_merkle_tree = 10;
inline void ProcessBatchRequest::clear_update_merkle_tree() {
  _impl_.update_merkle_tree_ = 0u;
}
inline uint32_t ProcessBatchRequest::_internal_update_merkle_tree() const {
  return _impl_.update_merkle_tree_;
}
inline uint32_t ProcessBatchRequest::update_merkle_tree() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.update_merkle_tree)
  return _internal_update_merkle_tree();
}
inline void ProcessBatchRequest::_internal_set_update_merkle_tree(uint32_t value) {
  
  _impl_.update_merkle_tree_ = value;
}
inline void ProcessBatchRequest::set_update_merkle_tree(uint32_t value) {
  _internal_set_update_merkle_tree(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.update_merkle_tree)
}

// uint64 no_counters = 11;
inline void ProcessBatchRequest::clear_no_counters() {
  _impl_.no_counters_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_no_counters() const {
  return _impl_.no_counters_;
}
inline uint64_t ProcessBatchRequest::no_counters() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.no_counters)
  return _internal_no_counters();
}
inline void ProcessBatchRequest::_internal_set_no_counters(uint64_t value) {
  
  _impl_.no_counters_ = value;
}
inline void ProcessBatchRequest::set_no_counters(uint64_t value) {
  _internal_set_no_counters(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.no_counters)
}

// string from = 12;
inline void ProcessBatchRequest::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::from() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.from)
}
inline std::string* ProcessBatchRequest::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.from)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_from() const {
  return _impl_.from_.Get();
}
inline void ProcessBatchRequest::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_from() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.from)
  return _impl_.from_.Release();
}
inline void ProcessBatchRequest::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.from)
}

// map<string, string> db = 13;
inline int ProcessBatchRequest::_internal_db_size() const {
  return _impl_.db_.size();
}
inline int ProcessBatchRequest::db_size() const {
  return _internal_db_size();
}
inline void ProcessBatchRequest::clear_db() {
  _impl_.db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::_internal_db() const {
  return _impl_.db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::db() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequest.db)
  return _internal_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::_internal_mutable_db() {
  return _impl_.db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::mutable_db() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequest.db)
  return _internal_mutable_db();
}

// map<string, string> contracts_bytecode = 14;
inline int ProcessBatchRequest::_internal_contracts_bytecode_size() const {
  return _impl_.contracts_bytecode_.size();
}
inline int ProcessBatchRequest::contracts_bytecode_size() const {
  return _internal_contracts_bytecode_size();
}
inline void ProcessBatchRequest::clear_contracts_bytecode() {
  _impl_.contracts_bytecode_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::_internal_contracts_bytecode() const {
  return _impl_.contracts_bytecode_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::contracts_bytecode() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequest.contracts_bytecode)
  return _internal_contracts_bytecode();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::_internal_mutable_contracts_bytecode() {
  return _impl_.contracts_bytecode_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::mutable_contracts_bytecode() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequest.contracts_bytecode)
  return _internal_mutable_contracts_bytecode();
}

// .executor.v1.TraceConfig trace_config = 15;
inline bool ProcessBatchRequest::_internal_has_trace_config() const {
  return this != internal_default_instance() && _impl_.trace_config_ != nullptr;
}
inline bool ProcessBatchRequest::has_trace_config() const {
  return _internal_has_trace_config();
}
inline void ProcessBatchRequest::clear_trace_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_config_ != nullptr) {
    delete _impl_.trace_config_;
  }
  _impl_.trace_config_ = nullptr;
}
inline const ::executor::v1::TraceConfig& ProcessBatchRequest::_internal_trace_config() const {
  const ::executor::v1::TraceConfig* p = _impl_.trace_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::TraceConfig&>(
      ::executor::v1::_TraceConfig_default_instance_);
}
inline const ::executor::v1::TraceConfig& ProcessBatchRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.trace_config)
  return _internal_trace_config();
}
inline void ProcessBatchRequest::unsafe_arena_set_allocated_trace_config(
    ::executor::v1::TraceConfig* trace_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_config_);
  }
  _impl_.trace_config_ = trace_config;
  if (trace_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessBatchRequest.trace_config)
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::release_trace_config() {
  
  ::executor::v1::TraceConfig* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::unsafe_arena_release_trace_config() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.trace_config)
  
  ::executor::v1::TraceConfig* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
  return temp;
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::_internal_mutable_trace_config() {
  
  if (_impl_.trace_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::TraceConfig>(GetArenaForAllocation());
    _impl_.trace_config_ = p;
  }
  return _impl_.trace_config_;
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::mutable_trace_config() {
  ::executor::v1::TraceConfig* _msg = _internal_mutable_trace_config();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.trace_config)
  return _msg;
}
inline void ProcessBatchRequest::set_allocated_trace_config(::executor::v1::TraceConfig* trace_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_config_;
  }
  if (trace_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_config);
    if (message_arena != submessage_arena) {
      trace_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_config_ = trace_config;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.trace_config)
}

// string context_id = 16;
inline void ProcessBatchRequest::clear_context_id() {
  _impl_.context_id_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::context_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.context_id)
  return _internal_context_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_context_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.context_id)
}
inline std::string* ProcessBatchRequest::mutable_context_id() {
  std::string* _s = _internal_mutable_context_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.context_id)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_context_id() const {
  return _impl_.context_id_.Get();
}
inline void ProcessBatchRequest::_internal_set_context_id(const std::string& value) {
  
  _impl_.context_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_context_id() {
  
  return _impl_.context_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_context_id() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.context_id)
  return _impl_.context_id_.Release();
}
inline void ProcessBatchRequest::set_allocated_context_id(std::string* context_id) {
  if (context_id != nullptr) {
    
  } else {
    
  }
  _impl_.context_id_.SetAllocated(context_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_id_.IsDefault()) {
    _impl_.context_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.context_id)
}

// uint32 get_keys = 17;
inline void ProcessBatchRequest::clear_get_keys() {
  _impl_.get_keys_ = 0u;
}
inline uint32_t ProcessBatchRequest::_internal_get_keys() const {
  return _impl_.get_keys_;
}
inline uint32_t ProcessBatchRequest::get_keys() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.get_keys)
  return _internal_get_keys();
}
inline void ProcessBatchRequest::_internal_set_get_keys(uint32_t value) {
  
  _impl_.get_keys_ = value;
}
inline void ProcessBatchRequest::set_get_keys(uint32_t value) {
  _internal_set_get_keys(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.get_keys)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessBatchResponse

// bytes new_state_root = 1;
inline void ProcessBatchResponse::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::new_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_state_root)
}
inline std::string* ProcessBatchResponse::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.new_state_root)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void ProcessBatchResponse::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_new_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void ProcessBatchResponse::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.new_state_root)
}

// bytes new_acc_input_hash = 2;
inline void ProcessBatchResponse::clear_new_acc_input_hash() {
  _impl_.new_acc_input_hash_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::new_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_acc_input_hash)
  return _internal_new_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_new_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_acc_input_hash)
}
inline std::string* ProcessBatchResponse::mutable_new_acc_input_hash() {
  std::string* _s = _internal_mutable_new_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.new_acc_input_hash)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_new_acc_input_hash() const {
  return _impl_.new_acc_input_hash_.Get();
}
inline void ProcessBatchResponse::_internal_set_new_acc_input_hash(const std::string& value) {
  
  _impl_.new_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_new_acc_input_hash() {
  
  return _impl_.new_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_new_acc_input_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.new_acc_input_hash)
  return _impl_.new_acc_input_hash_.Release();
}
inline void ProcessBatchResponse::set_allocated_new_acc_input_hash(std::string* new_acc_input_hash) {
  if (new_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.new_acc_input_hash_.SetAllocated(new_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_acc_input_hash_.IsDefault()) {
    _impl_.new_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.new_acc_input_hash)
}

// bytes new_local_exit_root = 3;
inline void ProcessBatchResponse::clear_new_local_exit_root() {
  _impl_.new_local_exit_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::new_local_exit_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_local_exit_root)
  return _internal_new_local_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_new_local_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_local_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_local_exit_root)
}
inline std::string* ProcessBatchResponse::mutable_new_local_exit_root() {
  std::string* _s = _internal_mutable_new_local_exit_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.new_local_exit_root)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_new_local_exit_root() const {
  return _impl_.new_local_exit_root_.Get();
}
inline void ProcessBatchResponse::_internal_set_new_local_exit_root(const std::string& value) {
  
  _impl_.new_local_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_new_local_exit_root() {
  
  return _impl_.new_local_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_new_local_exit_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.new_local_exit_root)
  return _impl_.new_local_exit_root_.Release();
}
inline void ProcessBatchResponse::set_allocated_new_local_exit_root(std::string* new_local_exit_root) {
  if (new_local_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_local_exit_root_.SetAllocated(new_local_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_local_exit_root_.IsDefault()) {
    _impl_.new_local_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.new_local_exit_root)
}

// uint64 new_batch_num = 4;
inline void ProcessBatchResponse::clear_new_batch_num() {
  _impl_.new_batch_num_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_new_batch_num() const {
  return _impl_.new_batch_num_;
}
inline uint64_t ProcessBatchResponse::new_batch_num() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_batch_num)
  return _internal_new_batch_num();
}
inline void ProcessBatchResponse::_internal_set_new_batch_num(uint64_t value) {
  
  _impl_.new_batch_num_ = value;
}
inline void ProcessBatchResponse::set_new_batch_num(uint64_t value) {
  _internal_set_new_batch_num(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_batch_num)
}

// uint32 cnt_keccak_hashes = 5;
inline void ProcessBatchResponse::clear_cnt_keccak_hashes() {
  _impl_.cnt_keccak_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_keccak_hashes() const {
  return _impl_.cnt_keccak_hashes_;
}
inline uint32_t ProcessBatchResponse::cnt_keccak_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_keccak_hashes)
  return _internal_cnt_keccak_hashes();
}
inline void ProcessBatchResponse::_internal_set_cnt_keccak_hashes(uint32_t value) {
  
  _impl_.cnt_keccak_hashes_ = value;
}
inline void ProcessBatchResponse::set_cnt_keccak_hashes(uint32_t value) {
  _internal_set_cnt_keccak_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_keccak_hashes)
}

// uint32 cnt_poseidon_hashes = 6;
inline void ProcessBatchResponse::clear_cnt_poseidon_hashes() {
  _impl_.cnt_poseidon_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_poseidon_hashes() const {
  return _impl_.cnt_poseidon_hashes_;
}
inline uint32_t ProcessBatchResponse::cnt_poseidon_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_poseidon_hashes)
  return _internal_cnt_poseidon_hashes();
}
inline void ProcessBatchResponse::_internal_set_cnt_poseidon_hashes(uint32_t value) {
  
  _impl_.cnt_poseidon_hashes_ = value;
}
inline void ProcessBatchResponse::set_cnt_poseidon_hashes(uint32_t value) {
  _internal_set_cnt_poseidon_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_poseidon_hashes)
}

// uint32 cnt_poseidon_paddings = 7;
inline void ProcessBatchResponse::clear_cnt_poseidon_paddings() {
  _impl_.cnt_poseidon_paddings_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_poseidon_paddings() const {
  return _impl_.cnt_poseidon_paddings_;
}
inline uint32_t ProcessBatchResponse::cnt_poseidon_paddings() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_poseidon_paddings)
  return _internal_cnt_poseidon_paddings();
}
inline void ProcessBatchResponse::_internal_set_cnt_poseidon_paddings(uint32_t value) {
  
  _impl_.cnt_poseidon_paddings_ = value;
}
inline void ProcessBatchResponse::set_cnt_poseidon_paddings(uint32_t value) {
  _internal_set_cnt_poseidon_paddings(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_poseidon_paddings)
}

// uint32 cnt_mem_aligns = 8;
inline void ProcessBatchResponse::clear_cnt_mem_aligns() {
  _impl_.cnt_mem_aligns_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_mem_aligns() const {
  return _impl_.cnt_mem_aligns_;
}
inline uint32_t ProcessBatchResponse::cnt_mem_aligns() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_mem_aligns)
  return _internal_cnt_mem_aligns();
}
inline void ProcessBatchResponse::_internal_set_cnt_mem_aligns(uint32_t value) {
  
  _impl_.cnt_mem_aligns_ = value;
}
inline void ProcessBatchResponse::set_cnt_mem_aligns(uint32_t value) {
  _internal_set_cnt_mem_aligns(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_mem_aligns)
}

// uint32 cnt_arithmetics = 9;
inline void ProcessBatchResponse::clear_cnt_arithmetics() {
  _impl_.cnt_arithmetics_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_arithmetics() const {
  return _impl_.cnt_arithmetics_;
}
inline uint32_t ProcessBatchResponse::cnt_arithmetics() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_arithmetics)
  return _internal_cnt_arithmetics();
}
inline void ProcessBatchResponse::_internal_set_cnt_arithmetics(uint32_t value) {
  
  _impl_.cnt_arithmetics_ = value;
}
inline void ProcessBatchResponse::set_cnt_arithmetics(uint32_t value) {
  _internal_set_cnt_arithmetics(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_arithmetics)
}

// uint32 cnt_binaries = 10;
inline void ProcessBatchResponse::clear_cnt_binaries() {
  _impl_.cnt_binaries_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_binaries() const {
  return _impl_.cnt_binaries_;
}
inline uint32_t ProcessBatchResponse::cnt_binaries() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_binaries)
  return _internal_cnt_binaries();
}
inline void ProcessBatchResponse::_internal_set_cnt_binaries(uint32_t value) {
  
  _impl_.cnt_binaries_ = value;
}
inline void ProcessBatchResponse::set_cnt_binaries(uint32_t value) {
  _internal_set_cnt_binaries(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_binaries)
}

// uint32 cnt_steps = 11;
inline void ProcessBatchResponse::clear_cnt_steps() {
  _impl_.cnt_steps_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_steps() const {
  return _impl_.cnt_steps_;
}
inline uint32_t ProcessBatchResponse::cnt_steps() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_steps)
  return _internal_cnt_steps();
}
inline void ProcessBatchResponse::_internal_set_cnt_steps(uint32_t value) {
  
  _impl_.cnt_steps_ = value;
}
inline void ProcessBatchResponse::set_cnt_steps(uint32_t value) {
  _internal_set_cnt_steps(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_steps)
}

// uint64 cumulative_gas_used = 12;
inline void ProcessBatchResponse::clear_cumulative_gas_used() {
  _impl_.cumulative_gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_cumulative_gas_used() const {
  return _impl_.cumulative_gas_used_;
}
inline uint64_t ProcessBatchResponse::cumulative_gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cumulative_gas_used)
  return _internal_cumulative_gas_used();
}
inline void ProcessBatchResponse::_internal_set_cumulative_gas_used(uint64_t value) {
  
  _impl_.cumulative_gas_used_ = value;
}
inline void ProcessBatchResponse::set_cumulative_gas_used(uint64_t value) {
  _internal_set_cumulative_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cumulative_gas_used)
}

// repeated .executor.v1.ProcessTransactionResponse responses = 13;
inline int ProcessBatchResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int ProcessBatchResponse::responses_size() const {
  return _internal_responses_size();
}
inline void ProcessBatchResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::executor::v1::ProcessTransactionResponse* ProcessBatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >*
ProcessBatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponse.responses)
  return &_impl_.responses_;
}
inline const ::executor::v1::ProcessTransactionResponse& ProcessBatchResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::executor::v1::ProcessTransactionResponse& ProcessBatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.responses)
  return _internal_responses(index);
}
inline ::executor::v1::ProcessTransactionResponse* ProcessBatchResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::executor::v1::ProcessTransactionResponse* ProcessBatchResponse::add_responses() {
  ::executor::v1::ProcessTransactionResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >&
ProcessBatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponse.responses)
  return _impl_.responses_;
}

// .executor.v1.ExecutorError error = 14;
inline void ProcessBatchResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::ExecutorError ProcessBatchResponse::_internal_error() const {
  return static_cast< ::executor::v1::ExecutorError >(_impl_.error_);
}
inline ::executor::v1::ExecutorError ProcessBatchResponse::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.error)
  return _internal_error();
}
inline void ProcessBatchResponse::_internal_set_error(::executor::v1::ExecutorError value) {
  
  _impl_.error_ = value;
}
inline void ProcessBatchResponse::set_error(::executor::v1::ExecutorError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.error)
}

// map<string, .executor.v1.InfoReadWrite> read_write_addresses = 15;
inline int ProcessBatchResponse::_internal_read_write_addresses_size() const {
  return _impl_.read_write_addresses_.size();
}
inline int ProcessBatchResponse::read_write_addresses_size() const {
  return _internal_read_write_addresses_size();
}
inline void ProcessBatchResponse::clear_read_write_addresses() {
  _impl_.read_write_addresses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
ProcessBatchResponse::_internal_read_write_addresses() const {
  return _impl_.read_write_addresses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
ProcessBatchResponse::read_write_addresses() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchResponse.read_write_addresses)
  return _internal_read_write_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
ProcessBatchResponse::_internal_mutable_read_write_addresses() {
  return _impl_.read_write_addresses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
ProcessBatchResponse::mutable_read_write_addresses() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchResponse.read_write_addresses)
  return _internal_mutable_read_write_addresses();
}

// uint64 flush_id = 16;
inline void ProcessBatchResponse::clear_flush_id() {
  _impl_.flush_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline uint64_t ProcessBatchResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.flush_id)
  return _internal_flush_id();
}
inline void ProcessBatchResponse::_internal_set_flush_id(uint64_t value) {
  
  _impl_.flush_id_ = value;
}
inline void ProcessBatchResponse::set_flush_id(uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.flush_id)
}

// uint64 stored_flush_id = 17;
inline void ProcessBatchResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t ProcessBatchResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void ProcessBatchResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void ProcessBatchResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.stored_flush_id)
}

// string prover_id = 18;
inline void ProcessBatchResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.prover_id)
}
inline std::string* ProcessBatchResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.prover_id)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void ProcessBatchResponse::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void ProcessBatchResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.prover_id)
}

// repeated bytes nodes_keys = 19;
inline int ProcessBatchResponse::_internal_nodes_keys_size() const {
  return _impl_.nodes_keys_.size();
}
inline int ProcessBatchResponse::nodes_keys_size() const {
  return _internal_nodes_keys_size();
}
inline void ProcessBatchResponse::clear_nodes_keys() {
  _impl_.nodes_keys_.Clear();
}
inline std::string* ProcessBatchResponse::add_nodes_keys() {
  std::string* _s = _internal_add_nodes_keys();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.ProcessBatchResponse.nodes_keys)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_nodes_keys(int index) const {
  return _impl_.nodes_keys_.Get(index);
}
inline const std::string& ProcessBatchResponse::nodes_keys(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.nodes_keys)
  return _internal_nodes_keys(index);
}
inline std::string* ProcessBatchResponse::mutable_nodes_keys(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.nodes_keys)
  return _impl_.nodes_keys_.Mutable(index);
}
inline void ProcessBatchResponse::set_nodes_keys(int index, const std::string& value) {
  _impl_.nodes_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline void ProcessBatchResponse::set_nodes_keys(int index, std::string&& value) {
  _impl_.nodes_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline void ProcessBatchResponse::set_nodes_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline void ProcessBatchResponse::set_nodes_keys(int index, const void* value, size_t size) {
  _impl_.nodes_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline std::string* ProcessBatchResponse::_internal_add_nodes_keys() {
  return _impl_.nodes_keys_.Add();
}
inline void ProcessBatchResponse::add_nodes_keys(const std::string& value) {
  _impl_.nodes_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline void ProcessBatchResponse::add_nodes_keys(std::string&& value) {
  _impl_.nodes_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline void ProcessBatchResponse::add_nodes_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline void ProcessBatchResponse::add_nodes_keys(const void* value, size_t size) {
  _impl_.nodes_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.ProcessBatchResponse.nodes_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessBatchResponse::nodes_keys() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponse.nodes_keys)
  return _impl_.nodes_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessBatchResponse::mutable_nodes_keys() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponse.nodes_keys)
  return &_impl_.nodes_keys_;
}

// repeated bytes program_keys = 20;
inline int ProcessBatchResponse::_internal_program_keys_size() const {
  return _impl_.program_keys_.size();
}
inline int ProcessBatchResponse::program_keys_size() const {
  return _internal_program_keys_size();
}
inline void ProcessBatchResponse::clear_program_keys() {
  _impl_.program_keys_.Clear();
}
inline std::string* ProcessBatchResponse::add_program_keys() {
  std::string* _s = _internal_add_program_keys();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.ProcessBatchResponse.program_keys)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_program_keys(int index) const {
  return _impl_.program_keys_.Get(index);
}
inline const std::string& ProcessBatchResponse::program_keys(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.program_keys)
  return _internal_program_keys(index);
}
inline std::string* ProcessBatchResponse::mutable_program_keys(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.program_keys)
  return _impl_.program_keys_.Mutable(index);
}
inline void ProcessBatchResponse::set_program_keys(int index, const std::string& value) {
  _impl_.program_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.program_keys)
}
inline void ProcessBatchResponse::set_program_keys(int index, std::string&& value) {
  _impl_.program_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.program_keys)
}
inline void ProcessBatchResponse::set_program_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.program_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.ProcessBatchResponse.program_keys)
}
inline void ProcessBatchResponse::set_program_keys(int index, const void* value, size_t size) {
  _impl_.program_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.ProcessBatchResponse.program_keys)
}
inline std::string* ProcessBatchResponse::_internal_add_program_keys() {
  return _impl_.program_keys_.Add();
}
inline void ProcessBatchResponse::add_program_keys(const std::string& value) {
  _impl_.program_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponse.program_keys)
}
inline void ProcessBatchResponse::add_program_keys(std::string&& value) {
  _impl_.program_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponse.program_keys)
}
inline void ProcessBatchResponse::add_program_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.program_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.ProcessBatchResponse.program_keys)
}
inline void ProcessBatchResponse::add_program_keys(const void* value, size_t size) {
  _impl_.program_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.ProcessBatchResponse.program_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessBatchResponse::program_keys() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponse.program_keys)
  return _impl_.program_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessBatchResponse::mutable_program_keys() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponse.program_keys)
  return &_impl_.program_keys_;
}

// -------------------------------------------------------------------

// GetFlushStatusResponse

// uint64 stored_flush_id = 1;
inline void GetFlushStatusResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t GetFlushStatusResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.stored_flush_id)
}

// uint64 storing_flush_id = 2;
inline void GetFlushStatusResponse::clear_storing_flush_id() {
  _impl_.storing_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_flush_id() const {
  return _impl_.storing_flush_id_;
}
inline uint64_t GetFlushStatusResponse::storing_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.storing_flush_id)
  return _internal_storing_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_storing_flush_id(uint64_t value) {
  
  _impl_.storing_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_storing_flush_id(uint64_t value) {
  _internal_set_storing_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.storing_flush_id)
}

// uint64 last_flush_id = 3;
inline void GetFlushStatusResponse::clear_last_flush_id() {
  _impl_.last_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_last_flush_id() const {
  return _impl_.last_flush_id_;
}
inline uint64_t GetFlushStatusResponse::last_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.last_flush_id)
  return _internal_last_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_last_flush_id(uint64_t value) {
  
  _impl_.last_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_last_flush_id(uint64_t value) {
  _internal_set_last_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.last_flush_id)
}

// uint64 pending_to_flush_nodes = 4;
inline void GetFlushStatusResponse::clear_pending_to_flush_nodes() {
  _impl_.pending_to_flush_nodes_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_pending_to_flush_nodes() const {
  return _impl_.pending_to_flush_nodes_;
}
inline uint64_t GetFlushStatusResponse::pending_to_flush_nodes() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.pending_to_flush_nodes)
  return _internal_pending_to_flush_nodes();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_nodes(uint64_t value) {
  
  _impl_.pending_to_flush_nodes_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_nodes(uint64_t value) {
  _internal_set_pending_to_flush_nodes(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.pending_to_flush_nodes)
}

// uint64 pending_to_flush_program = 5;
inline void GetFlushStatusResponse::clear_pending_to_flush_program() {
  _impl_.pending_to_flush_program_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_pending_to_flush_program() const {
  return _impl_.pending_to_flush_program_;
}
inline uint64_t GetFlushStatusResponse::pending_to_flush_program() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.pending_to_flush_program)
  return _internal_pending_to_flush_program();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_program(uint64_t value) {
  
  _impl_.pending_to_flush_program_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_program(uint64_t value) {
  _internal_set_pending_to_flush_program(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.pending_to_flush_program)
}

// uint64 storing_nodes = 6;
inline void GetFlushStatusResponse::clear_storing_nodes() {
  _impl_.storing_nodes_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_nodes() const {
  return _impl_.storing_nodes_;
}
inline uint64_t GetFlushStatusResponse::storing_nodes() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.storing_nodes)
  return _internal_storing_nodes();
}
inline void GetFlushStatusResponse::_internal_set_storing_nodes(uint64_t value) {
  
  _impl_.storing_nodes_ = value;
}
inline void GetFlushStatusResponse::set_storing_nodes(uint64_t value) {
  _internal_set_storing_nodes(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.storing_nodes)
}

// uint64 storing_program = 7;
inline void GetFlushStatusResponse::clear_storing_program() {
  _impl_.storing_program_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_program() const {
  return _impl_.storing_program_;
}
inline uint64_t GetFlushStatusResponse::storing_program() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.storing_program)
  return _internal_storing_program();
}
inline void GetFlushStatusResponse::_internal_set_storing_program(uint64_t value) {
  
  _impl_.storing_program_ = value;
}
inline void GetFlushStatusResponse::set_storing_program(uint64_t value) {
  _internal_set_storing_program(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.storing_program)
}

// string prover_id = 8;
inline void GetFlushStatusResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& GetFlushStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFlushStatusResponse::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.GetFlushStatusResponse.prover_id)
  return _s;
}
inline const std::string& GetFlushStatusResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void GetFlushStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:executor.v1.GetFlushStatusResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void GetFlushStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.GetFlushStatusResponse.prover_id)
}

// -------------------------------------------------------------------

// TraceConfig

// uint32 disable_storage = 1;
inline void TraceConfig::clear_disable_storage() {
  _impl_.disable_storage_ = 0u;
}
inline uint32_t TraceConfig::_internal_disable_storage() const {
  return _impl_.disable_storage_;
}
inline uint32_t TraceConfig::disable_storage() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.disable_storage)
  return _internal_disable_storage();
}
inline void TraceConfig::_internal_set_disable_storage(uint32_t value) {
  
  _impl_.disable_storage_ = value;
}
inline void TraceConfig::set_disable_storage(uint32_t value) {
  _internal_set_disable_storage(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.disable_storage)
}

// uint32 disable_stack = 2;
inline void TraceConfig::clear_disable_stack() {
  _impl_.disable_stack_ = 0u;
}
inline uint32_t TraceConfig::_internal_disable_stack() const {
  return _impl_.disable_stack_;
}
inline uint32_t TraceConfig::disable_stack() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.disable_stack)
  return _internal_disable_stack();
}
inline void TraceConfig::_internal_set_disable_stack(uint32_t value) {
  
  _impl_.disable_stack_ = value;
}
inline void TraceConfig::set_disable_stack(uint32_t value) {
  _internal_set_disable_stack(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.disable_stack)
}

// uint32 enable_memory = 3;
inline void TraceConfig::clear_enable_memory() {
  _impl_.enable_memory_ = 0u;
}
inline uint32_t TraceConfig::_internal_enable_memory() const {
  return _impl_.enable_memory_;
}
inline uint32_t TraceConfig::enable_memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.enable_memory)
  return _internal_enable_memory();
}
inline void TraceConfig::_internal_set_enable_memory(uint32_t value) {
  
  _impl_.enable_memory_ = value;
}
inline void TraceConfig::set_enable_memory(uint32_t value) {
  _internal_set_enable_memory(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.enable_memory)
}

// uint32 enable_return_data = 4;
inline void TraceConfig::clear_enable_return_data() {
  _impl_.enable_return_data_ = 0u;
}
inline uint32_t TraceConfig::_internal_enable_return_data() const {
  return _impl_.enable_return_data_;
}
inline uint32_t TraceConfig::enable_return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.enable_return_data)
  return _internal_enable_return_data();
}
inline void TraceConfig::_internal_set_enable_return_data(uint32_t value) {
  
  _impl_.enable_return_data_ = value;
}
inline void TraceConfig::set_enable_return_data(uint32_t value) {
  _internal_set_enable_return_data(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.enable_return_data)
}

// bytes tx_hash_to_generate_execute_trace = 5;
inline void TraceConfig::clear_tx_hash_to_generate_execute_trace() {
  _impl_.tx_hash_to_generate_execute_trace_.ClearToEmpty();
}
inline const std::string& TraceConfig::tx_hash_to_generate_execute_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.tx_hash_to_generate_execute_trace)
  return _internal_tx_hash_to_generate_execute_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceConfig::set_tx_hash_to_generate_execute_trace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_to_generate_execute_trace_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.tx_hash_to_generate_execute_trace)
}
inline std::string* TraceConfig::mutable_tx_hash_to_generate_execute_trace() {
  std::string* _s = _internal_mutable_tx_hash_to_generate_execute_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.TraceConfig.tx_hash_to_generate_execute_trace)
  return _s;
}
inline const std::string& TraceConfig::_internal_tx_hash_to_generate_execute_trace() const {
  return _impl_.tx_hash_to_generate_execute_trace_.Get();
}
inline void TraceConfig::_internal_set_tx_hash_to_generate_execute_trace(const std::string& value) {
  
  _impl_.tx_hash_to_generate_execute_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceConfig::_internal_mutable_tx_hash_to_generate_execute_trace() {
  
  return _impl_.tx_hash_to_generate_execute_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceConfig::release_tx_hash_to_generate_execute_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.TraceConfig.tx_hash_to_generate_execute_trace)
  return _impl_.tx_hash_to_generate_execute_trace_.Release();
}
inline void TraceConfig::set_allocated_tx_hash_to_generate_execute_trace(std::string* tx_hash_to_generate_execute_trace) {
  if (tx_hash_to_generate_execute_trace != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_to_generate_execute_trace_.SetAllocated(tx_hash_to_generate_execute_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_to_generate_execute_trace_.IsDefault()) {
    _impl_.tx_hash_to_generate_execute_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TraceConfig.tx_hash_to_generate_execute_trace)
}

// bytes tx_hash_to_generate_call_trace = 6;
inline void TraceConfig::clear_tx_hash_to_generate_call_trace() {
  _impl_.tx_hash_to_generate_call_trace_.ClearToEmpty();
}
inline const std::string& TraceConfig::tx_hash_to_generate_call_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.tx_hash_to_generate_call_trace)
  return _internal_tx_hash_to_generate_call_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceConfig::set_tx_hash_to_generate_call_trace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_to_generate_call_trace_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.tx_hash_to_generate_call_trace)
}
inline std::string* TraceConfig::mutable_tx_hash_to_generate_call_trace() {
  std::string* _s = _internal_mutable_tx_hash_to_generate_call_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.TraceConfig.tx_hash_to_generate_call_trace)
  return _s;
}
inline const std::string& TraceConfig::_internal_tx_hash_to_generate_call_trace() const {
  return _impl_.tx_hash_to_generate_call_trace_.Get();
}
inline void TraceConfig::_internal_set_tx_hash_to_generate_call_trace(const std::string& value) {
  
  _impl_.tx_hash_to_generate_call_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceConfig::_internal_mutable_tx_hash_to_generate_call_trace() {
  
  return _impl_.tx_hash_to_generate_call_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceConfig::release_tx_hash_to_generate_call_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.TraceConfig.tx_hash_to_generate_call_trace)
  return _impl_.tx_hash_to_generate_call_trace_.Release();
}
inline void TraceConfig::set_allocated_tx_hash_to_generate_call_trace(std::string* tx_hash_to_generate_call_trace) {
  if (tx_hash_to_generate_call_trace != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_to_generate_call_trace_.SetAllocated(tx_hash_to_generate_call_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_to_generate_call_trace_.IsDefault()) {
    _impl_.tx_hash_to_generate_call_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TraceConfig.tx_hash_to_generate_call_trace)
}

// -------------------------------------------------------------------

// InfoReadWrite

// string nonce = 1;
inline void InfoReadWrite::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& InfoReadWrite::nonce() const {
  // @@protoc_insertion_point(field_get:executor.v1.InfoReadWrite.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoReadWrite::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.InfoReadWrite.nonce)
}
inline std::string* InfoReadWrite::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:executor.v1.InfoReadWrite.nonce)
  return _s;
}
inline const std::string& InfoReadWrite::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void InfoReadWrite::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoReadWrite::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoReadWrite::release_nonce() {
  // @@protoc_insertion_point(field_release:executor.v1.InfoReadWrite.nonce)
  return _impl_.nonce_.Release();
}
inline void InfoReadWrite::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.InfoReadWrite.nonce)
}

// string balance = 2;
inline void InfoReadWrite::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& InfoReadWrite::balance() const {
  // @@protoc_insertion_point(field_get:executor.v1.InfoReadWrite.balance)
  return _internal_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoReadWrite::set_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.balance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.InfoReadWrite.balance)
}
inline std::string* InfoReadWrite::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:executor.v1.InfoReadWrite.balance)
  return _s;
}
inline const std::string& InfoReadWrite::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void InfoReadWrite::_internal_set_balance(const std::string& value) {
  
  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoReadWrite::_internal_mutable_balance() {
  
  return _impl_.balance_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoReadWrite::release_balance() {
  // @@protoc_insertion_point(field_release:executor.v1.InfoReadWrite.balance)
  return _impl_.balance_.Release();
}
inline void InfoReadWrite::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  _impl_.balance_.SetAllocated(balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.InfoReadWrite.balance)
}

// -------------------------------------------------------------------

// CallTrace

// .executor.v1.TransactionContext context = 1;
inline bool CallTrace::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool CallTrace::has_context() const {
  return _internal_has_context();
}
inline void CallTrace::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::executor::v1::TransactionContext& CallTrace::_internal_context() const {
  const ::executor::v1::TransactionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::TransactionContext&>(
      ::executor::v1::_TransactionContext_default_instance_);
}
inline const ::executor::v1::TransactionContext& CallTrace::context() const {
  // @@protoc_insertion_point(field_get:executor.v1.CallTrace.context)
  return _internal_context();
}
inline void CallTrace::unsafe_arena_set_allocated_context(
    ::executor::v1::TransactionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.CallTrace.context)
}
inline ::executor::v1::TransactionContext* CallTrace::release_context() {
  
  ::executor::v1::TransactionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::TransactionContext* CallTrace::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:executor.v1.CallTrace.context)
  
  ::executor::v1::TransactionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::executor::v1::TransactionContext* CallTrace::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::TransactionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::executor::v1::TransactionContext* CallTrace::mutable_context() {
  ::executor::v1::TransactionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:executor.v1.CallTrace.context)
  return _msg;
}
inline void CallTrace::set_allocated_context(::executor::v1::TransactionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.CallTrace.context)
}

// repeated .executor.v1.TransactionStep steps = 2;
inline int CallTrace::_internal_steps_size() const {
  return _impl_.steps_.size();
}
inline int CallTrace::steps_size() const {
  return _internal_steps_size();
}
inline void CallTrace::clear_steps() {
  _impl_.steps_.Clear();
}
inline ::executor::v1::TransactionStep* CallTrace::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.CallTrace.steps)
  return _impl_.steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >*
CallTrace::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.CallTrace.steps)
  return &_impl_.steps_;
}
inline const ::executor::v1::TransactionStep& CallTrace::_internal_steps(int index) const {
  return _impl_.steps_.Get(index);
}
inline const ::executor::v1::TransactionStep& CallTrace::steps(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.CallTrace.steps)
  return _internal_steps(index);
}
inline ::executor::v1::TransactionStep* CallTrace::_internal_add_steps() {
  return _impl_.steps_.Add();
}
inline ::executor::v1::TransactionStep* CallTrace::add_steps() {
  ::executor::v1::TransactionStep* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:executor.v1.CallTrace.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >&
CallTrace::steps() const {
  // @@protoc_insertion_point(field_list:executor.v1.CallTrace.steps)
  return _impl_.steps_;
}

// -------------------------------------------------------------------

// TransactionContext

// string type = 1;
inline void TransactionContext::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TransactionContext::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.type)
}
inline std::string* TransactionContext::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.type)
  return _s;
}
inline const std::string& TransactionContext::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TransactionContext::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_type() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.type)
  return _impl_.type_.Release();
}
inline void TransactionContext::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.type)
}

// string from = 2;
inline void TransactionContext::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& TransactionContext::from() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.from)
}
inline std::string* TransactionContext::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.from)
  return _s;
}
inline const std::string& TransactionContext::_internal_from() const {
  return _impl_.from_.Get();
}
inline void TransactionContext::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_from() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.from)
  return _impl_.from_.Release();
}
inline void TransactionContext::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.from)
}

// string to = 3;
inline void TransactionContext::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& TransactionContext::to() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.to)
}
inline std::string* TransactionContext::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.to)
  return _s;
}
inline const std::string& TransactionContext::_internal_to() const {
  return _impl_.to_.Get();
}
inline void TransactionContext::_internal_set_to(const std::string& value) {
  
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_to() {
  
  return _impl_.to_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_to() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.to)
  return _impl_.to_.Release();
}
inline void TransactionContext::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  _impl_.to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.to)
}

// bytes data = 4;
inline void TransactionContext::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TransactionContext::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.data)
}
inline std::string* TransactionContext::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.data)
  return _s;
}
inline const std::string& TransactionContext::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TransactionContext::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.data)
  return _impl_.data_.Release();
}
inline void TransactionContext::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.data)
}

// uint64 gas = 5;
inline void TransactionContext::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TransactionContext::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TransactionContext::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.gas)
  return _internal_gas();
}
inline void TransactionContext::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TransactionContext::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.gas)
}

// string value = 6;
inline void TransactionContext::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& TransactionContext::value() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.value)
}
inline std::string* TransactionContext::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.value)
  return _s;
}
inline const std::string& TransactionContext::_internal_value() const {
  return _impl_.value_.Get();
}
inline void TransactionContext::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_value() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.value)
  return _impl_.value_.Release();
}
inline void TransactionContext::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.value)
}

// bytes batch = 7;
inline void TransactionContext::clear_batch() {
  _impl_.batch_.ClearToEmpty();
}
inline const std::string& TransactionContext::batch() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.batch)
  return _internal_batch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_batch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.batch)
}
inline std::string* TransactionContext::mutable_batch() {
  std::string* _s = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.batch)
  return _s;
}
inline const std::string& TransactionContext::_internal_batch() const {
  return _impl_.batch_.Get();
}
inline void TransactionContext::_internal_set_batch(const std::string& value) {
  
  _impl_.batch_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_batch() {
  
  return _impl_.batch_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_batch() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.batch)
  return _impl_.batch_.Release();
}
inline void TransactionContext::set_allocated_batch(std::string* batch) {
  if (batch != nullptr) {
    
  } else {
    
  }
  _impl_.batch_.SetAllocated(batch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_.IsDefault()) {
    _impl_.batch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.batch)
}

// bytes output = 8;
inline void TransactionContext::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& TransactionContext::output() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.output)
}
inline std::string* TransactionContext::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.output)
  return _s;
}
inline const std::string& TransactionContext::_internal_output() const {
  return _impl_.output_.Get();
}
inline void TransactionContext::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_output() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.output)
  return _impl_.output_.Release();
}
inline void TransactionContext::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.output)
}

// uint64 gas_used = 9;
inline void TransactionContext::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t TransactionContext::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t TransactionContext::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.gas_used)
  return _internal_gas_used();
}
inline void TransactionContext::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void TransactionContext::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.gas_used)
}

// string gas_price = 10;
inline void TransactionContext::clear_gas_price() {
  _impl_.gas_price_.ClearToEmpty();
}
inline const std::string& TransactionContext::gas_price() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.gas_price)
  return _internal_gas_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_gas_price(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gas_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.gas_price)
}
inline std::string* TransactionContext::mutable_gas_price() {
  std::string* _s = _internal_mutable_gas_price();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.gas_price)
  return _s;
}
inline const std::string& TransactionContext::_internal_gas_price() const {
  return _impl_.gas_price_.Get();
}
inline void TransactionContext::_internal_set_gas_price(const std::string& value) {
  
  _impl_.gas_price_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_gas_price() {
  
  return _impl_.gas_price_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_gas_price() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.gas_price)
  return _impl_.gas_price_.Release();
}
inline void TransactionContext::set_allocated_gas_price(std::string* gas_price) {
  if (gas_price != nullptr) {
    
  } else {
    
  }
  _impl_.gas_price_.SetAllocated(gas_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gas_price_.IsDefault()) {
    _impl_.gas_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.gas_price)
}

// uint32 execution_time = 11;
inline void TransactionContext::clear_execution_time() {
  _impl_.execution_time_ = 0u;
}
inline uint32_t TransactionContext::_internal_execution_time() const {
  return _impl_.execution_time_;
}
inline uint32_t TransactionContext::execution_time() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.execution_time)
  return _internal_execution_time();
}
inline void TransactionContext::_internal_set_execution_time(uint32_t value) {
  
  _impl_.execution_time_ = value;
}
inline void TransactionContext::set_execution_time(uint32_t value) {
  _internal_set_execution_time(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.execution_time)
}

// bytes old_state_root = 12;
inline void TransactionContext::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& TransactionContext::old_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.old_state_root)
}
inline std::string* TransactionContext::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.old_state_root)
  return _s;
}
inline const std::string& TransactionContext::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void TransactionContext::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_old_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void TransactionContext::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.old_state_root)
}

// -------------------------------------------------------------------

// TransactionStep

// bytes state_root = 1;
inline void TransactionStep::clear_state_root() {
  _impl_.state_root_.ClearToEmpty();
}
inline const std::string& TransactionStep::state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.state_root)
  return _internal_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStep::set_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.state_root)
}
inline std::string* TransactionStep::mutable_state_root() {
  std::string* _s = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.state_root)
  return _s;
}
inline const std::string& TransactionStep::_internal_state_root() const {
  return _impl_.state_root_.Get();
}
inline void TransactionStep::_internal_set_state_root(const std::string& value) {
  
  _impl_.state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStep::_internal_mutable_state_root() {
  
  return _impl_.state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStep::release_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.state_root)
  return _impl_.state_root_.Release();
}
inline void TransactionStep::set_allocated_state_root(std::string* state_root) {
  if (state_root != nullptr) {
    
  } else {
    
  }
  _impl_.state_root_.SetAllocated(state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_root_.IsDefault()) {
    _impl_.state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.state_root)
}

// uint32 depth = 2;
inline void TransactionStep::clear_depth() {
  _impl_.depth_ = 0u;
}
inline uint32_t TransactionStep::_internal_depth() const {
  return _impl_.depth_;
}
inline uint32_t TransactionStep::depth() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.depth)
  return _internal_depth();
}
inline void TransactionStep::_internal_set_depth(uint32_t value) {
  
  _impl_.depth_ = value;
}
inline void TransactionStep::set_depth(uint32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.depth)
}

// uint64 pc = 3;
inline void TransactionStep::clear_pc() {
  _impl_.pc_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_pc() const {
  return _impl_.pc_;
}
inline uint64_t TransactionStep::pc() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.pc)
  return _internal_pc();
}
inline void TransactionStep::_internal_set_pc(uint64_t value) {
  
  _impl_.pc_ = value;
}
inline void TransactionStep::set_pc(uint64_t value) {
  _internal_set_pc(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.pc)
}

// uint64 gas = 4;
inline void TransactionStep::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TransactionStep::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.gas)
  return _internal_gas();
}
inline void TransactionStep::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TransactionStep::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.gas)
}

// uint64 gas_cost = 5;
inline void TransactionStep::clear_gas_cost() {
  _impl_.gas_cost_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_gas_cost() const {
  return _impl_.gas_cost_;
}
inline uint64_t TransactionStep::gas_cost() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.gas_cost)
  return _internal_gas_cost();
}
inline void TransactionStep::_internal_set_gas_cost(uint64_t value) {
  
  _impl_.gas_cost_ = value;
}
inline void TransactionStep::set_gas_cost(uint64_t value) {
  _internal_set_gas_cost(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.gas_cost)
}

// uint64 gas_refund = 6;
inline void TransactionStep::clear_gas_refund() {
  _impl_.gas_refund_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_gas_refund() const {
  return _impl_.gas_refund_;
}
inline uint64_t TransactionStep::gas_refund() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.gas_refund)
  return _internal_gas_refund();
}
inline void TransactionStep::_internal_set_gas_refund(uint64_t value) {
  
  _impl_.gas_refund_ = value;
}
inline void TransactionStep::set_gas_refund(uint64_t value) {
  _internal_set_gas_refund(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.gas_refund)
}

// uint32 op = 7;
inline void TransactionStep::clear_op() {
  _impl_.op_ = 0u;
}
inline uint32_t TransactionStep::_internal_op() const {
  return _impl_.op_;
}
inline uint32_t TransactionStep::op() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.op)
  return _internal_op();
}
inline void TransactionStep::_internal_set_op(uint32_t value) {
  
  _impl_.op_ = value;
}
inline void TransactionStep::set_op(uint32_t value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.op)
}

// repeated string stack = 8;
inline int TransactionStep::_internal_stack_size() const {
  return _impl_.stack_.size();
}
inline int TransactionStep::stack_size() const {
  return _internal_stack_size();
}
inline void TransactionStep::clear_stack() {
  _impl_.stack_.Clear();
}
inline std::string* TransactionStep::add_stack() {
  std::string* _s = _internal_add_stack();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.TransactionStep.stack)
  return _s;
}
inline const std::string& TransactionStep::_internal_stack(int index) const {
  return _impl_.stack_.Get(index);
}
inline const std::string& TransactionStep::stack(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.stack)
  return _internal_stack(index);
}
inline std::string* TransactionStep::mutable_stack(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.stack)
  return _impl_.stack_.Mutable(index);
}
inline void TransactionStep::set_stack(int index, const std::string& value) {
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::set_stack(int index, std::string&& value) {
  _impl_.stack_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::set_stack(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::set_stack(int index, const char* value, size_t size) {
  _impl_.stack_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.TransactionStep.stack)
}
inline std::string* TransactionStep::_internal_add_stack() {
  return _impl_.stack_.Add();
}
inline void TransactionStep::add_stack(const std::string& value) {
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::add_stack(std::string&& value) {
  _impl_.stack_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::add_stack(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::add_stack(const char* value, size_t size) {
  _impl_.stack_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.TransactionStep.stack)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionStep::stack() const {
  // @@protoc_insertion_point(field_list:executor.v1.TransactionStep.stack)
  return _impl_.stack_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionStep::mutable_stack() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.TransactionStep.stack)
  return &_impl_.stack_;
}

// bytes memory = 9;
inline void TransactionStep::clear_memory() {
  _impl_.memory_.ClearToEmpty();
}
inline const std::string& TransactionStep::memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.memory)
  return _internal_memory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStep::set_memory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.memory)
}
inline std::string* TransactionStep::mutable_memory() {
  std::string* _s = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.memory)
  return _s;
}
inline const std::string& TransactionStep::_internal_memory() const {
  return _impl_.memory_.Get();
}
inline void TransactionStep::_internal_set_memory(const std::string& value) {
  
  _impl_.memory_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStep::_internal_mutable_memory() {
  
  return _impl_.memory_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStep::release_memory() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.memory)
  return _impl_.memory_.Release();
}
inline void TransactionStep::set_allocated_memory(std::string* memory) {
  if (memory != nullptr) {
    
  } else {
    
  }
  _impl_.memory_.SetAllocated(memory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memory_.IsDefault()) {
    _impl_.memory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.memory)
}

// uint32 memory_size = 10;
inline void TransactionStep::clear_memory_size() {
  _impl_.memory_size_ = 0u;
}
inline uint32_t TransactionStep::_internal_memory_size() const {
  return _impl_.memory_size_;
}
inline uint32_t TransactionStep::memory_size() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.memory_size)
  return _internal_memory_size();
}
inline void TransactionStep::_internal_set_memory_size(uint32_t value) {
  
  _impl_.memory_size_ = value;
}
inline void TransactionStep::set_memory_size(uint32_t value) {
  _internal_set_memory_size(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.memory_size)
}

// uint32 memory_offset = 11;
inline void TransactionStep::clear_memory_offset() {
  _impl_.memory_offset_ = 0u;
}
inline uint32_t TransactionStep::_internal_memory_offset() const {
  return _impl_.memory_offset_;
}
inline uint32_t TransactionStep::memory_offset() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.memory_offset)
  return _internal_memory_offset();
}
inline void TransactionStep::_internal_set_memory_offset(uint32_t value) {
  
  _impl_.memory_offset_ = value;
}
inline void TransactionStep::set_memory_offset(uint32_t value) {
  _internal_set_memory_offset(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.memory_offset)
}

// bytes return_data = 12;
inline void TransactionStep::clear_return_data() {
  _impl_.return_data_.ClearToEmpty();
}
inline const std::string& TransactionStep::return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.return_data)
  return _internal_return_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStep::set_return_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.return_data)
}
inline std::string* TransactionStep::mutable_return_data() {
  std::string* _s = _internal_mutable_return_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.return_data)
  return _s;
}
inline const std::string& TransactionStep::_internal_return_data() const {
  return _impl_.return_data_.Get();
}
inline void TransactionStep::_internal_set_return_data(const std::string& value) {
  
  _impl_.return_data_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStep::_internal_mutable_return_data() {
  
  return _impl_.return_data_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStep::release_return_data() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.return_data)
  return _impl_.return_data_.Release();
}
inline void TransactionStep::set_allocated_return_data(std::string* return_data) {
  if (return_data != nullptr) {
    
  } else {
    
  }
  _impl_.return_data_.SetAllocated(return_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_data_.IsDefault()) {
    _impl_.return_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.return_data)
}

// .executor.v1.Contract contract = 13;
inline bool TransactionStep::_internal_has_contract() const {
  return this != internal_default_instance() && _impl_.contract_ != nullptr;
}
inline bool TransactionStep::has_contract() const {
  return _internal_has_contract();
}
inline void TransactionStep::clear_contract() {
  if (GetArenaForAllocation() == nullptr && _impl_.contract_ != nullptr) {
    delete _impl_.contract_;
  }
  _impl_.contract_ = nullptr;
}
inline const ::executor::v1::Contract& TransactionStep::_internal_contract() const {
  const ::executor::v1::Contract* p = _impl_.contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::Contract&>(
      ::executor::v1::_Contract_default_instance_);
}
inline const ::executor::v1::Contract& TransactionStep::contract() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.contract)
  return _internal_contract();
}
inline void TransactionStep::unsafe_arena_set_allocated_contract(
    ::executor::v1::Contract* contract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_);
  }
  _impl_.contract_ = contract;
  if (contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.TransactionStep.contract)
}
inline ::executor::v1::Contract* TransactionStep::release_contract() {
  
  ::executor::v1::Contract* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::Contract* TransactionStep::unsafe_arena_release_contract() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.contract)
  
  ::executor::v1::Contract* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
  return temp;
}
inline ::executor::v1::Contract* TransactionStep::_internal_mutable_contract() {
  
  if (_impl_.contract_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::Contract>(GetArenaForAllocation());
    _impl_.contract_ = p;
  }
  return _impl_.contract_;
}
inline ::executor::v1::Contract* TransactionStep::mutable_contract() {
  ::executor::v1::Contract* _msg = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.contract)
  return _msg;
}
inline void TransactionStep::set_allocated_contract(::executor::v1::Contract* contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_;
  }
  if (contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract);
    if (message_arena != submessage_arena) {
      contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.contract)
}

// .executor.v1.RomError error = 14;
inline void TransactionStep::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError TransactionStep::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError TransactionStep::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.error)
  return _internal_error();
}
inline void TransactionStep::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void TransactionStep::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.error)
}

// -------------------------------------------------------------------

// Contract

// string address = 1;
inline void Contract::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Contract::address() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.address)
}
inline std::string* Contract::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.address)
  return _s;
}
inline const std::string& Contract::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Contract::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_address() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.address)
  return _impl_.address_.Release();
}
inline void Contract::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.address)
}

// string caller = 2;
inline void Contract::clear_caller() {
  _impl_.caller_.ClearToEmpty();
}
inline const std::string& Contract::caller() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_caller(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caller_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.caller)
}
inline std::string* Contract::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.caller)
  return _s;
}
inline const std::string& Contract::_internal_caller() const {
  return _impl_.caller_.Get();
}
inline void Contract::_internal_set_caller(const std::string& value) {
  
  _impl_.caller_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_caller() {
  
  return _impl_.caller_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_caller() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.caller)
  return _impl_.caller_.Release();
}
inline void Contract::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  _impl_.caller_.SetAllocated(caller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caller_.IsDefault()) {
    _impl_.caller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.caller)
}

// string value = 3;
inline void Contract::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Contract::value() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.value)
}
inline std::string* Contract::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.value)
  return _s;
}
inline const std::string& Contract::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Contract::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_value() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.value)
  return _impl_.value_.Release();
}
inline void Contract::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.value)
}

// bytes data = 4;
inline void Contract::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Contract::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.data)
}
inline std::string* Contract::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.data)
  return _s;
}
inline const std::string& Contract::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Contract::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.data)
  return _impl_.data_.Release();
}
inline void Contract::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.data)
}

// uint64 gas = 5;
inline void Contract::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t Contract::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t Contract::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.gas)
  return _internal_gas();
}
inline void Contract::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void Contract::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.Contract.gas)
}

// string type = 6;
inline void Contract::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Contract::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.type)
}
inline std::string* Contract::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.type)
  return _s;
}
inline const std::string& Contract::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Contract::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_type() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.type)
  return _impl_.type_.Release();
}
inline void Contract::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.type)
}

// -------------------------------------------------------------------

// ProcessTransactionResponse

// bytes tx_hash = 1;
inline void ProcessTransactionResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.tx_hash)
}
inline std::string* ProcessTransactionResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.tx_hash)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void ProcessTransactionResponse::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void ProcessTransactionResponse::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.tx_hash)
}

// bytes rlp_tx = 2;
inline void ProcessTransactionResponse::clear_rlp_tx() {
  _impl_.rlp_tx_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::rlp_tx() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.rlp_tx)
  return _internal_rlp_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_rlp_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rlp_tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.rlp_tx)
}
inline std::string* ProcessTransactionResponse::mutable_rlp_tx() {
  std::string* _s = _internal_mutable_rlp_tx();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.rlp_tx)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_rlp_tx() const {
  return _impl_.rlp_tx_.Get();
}
inline void ProcessTransactionResponse::_internal_set_rlp_tx(const std::string& value) {
  
  _impl_.rlp_tx_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_rlp_tx() {
  
  return _impl_.rlp_tx_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_rlp_tx() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.rlp_tx)
  return _impl_.rlp_tx_.Release();
}
inline void ProcessTransactionResponse::set_allocated_rlp_tx(std::string* rlp_tx) {
  if (rlp_tx != nullptr) {
    
  } else {
    
  }
  _impl_.rlp_tx_.SetAllocated(rlp_tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlp_tx_.IsDefault()) {
    _impl_.rlp_tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.rlp_tx)
}

// uint32 type = 3;
inline void ProcessTransactionResponse::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t ProcessTransactionResponse::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.type)
  return _internal_type();
}
inline void ProcessTransactionResponse::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void ProcessTransactionResponse::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.type)
}

// bytes return_value = 4;
inline void ProcessTransactionResponse::clear_return_value() {
  _impl_.return_value_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::return_value() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.return_value)
  return _internal_return_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_return_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.return_value)
}
inline std::string* ProcessTransactionResponse::mutable_return_value() {
  std::string* _s = _internal_mutable_return_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.return_value)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_return_value() const {
  return _impl_.return_value_.Get();
}
inline void ProcessTransactionResponse::_internal_set_return_value(const std::string& value) {
  
  _impl_.return_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_return_value() {
  
  return _impl_.return_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_return_value() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.return_value)
  return _impl_.return_value_.Release();
}
inline void ProcessTransactionResponse::set_allocated_return_value(std::string* return_value) {
  if (return_value != nullptr) {
    
  } else {
    
  }
  _impl_.return_value_.SetAllocated(return_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_value_.IsDefault()) {
    _impl_.return_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.return_value)
}

// uint64 gas_left = 5;
inline void ProcessTransactionResponse::clear_gas_left() {
  _impl_.gas_left_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponse::_internal_gas_left() const {
  return _impl_.gas_left_;
}
inline uint64_t ProcessTransactionResponse::gas_left() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.gas_left)
  return _internal_gas_left();
}
inline void ProcessTransactionResponse::_internal_set_gas_left(uint64_t value) {
  
  _impl_.gas_left_ = value;
}
inline void ProcessTransactionResponse::set_gas_left(uint64_t value) {
  _internal_set_gas_left(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.gas_left)
}

// uint64 gas_used = 6;
inline void ProcessTransactionResponse::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponse::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t ProcessTransactionResponse::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.gas_used)
  return _internal_gas_used();
}
inline void ProcessTransactionResponse::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void ProcessTransactionResponse::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.gas_used)
}

// uint64 gas_refunded = 7;
inline void ProcessTransactionResponse::clear_gas_refunded() {
  _impl_.gas_refunded_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponse::_internal_gas_refunded() const {
  return _impl_.gas_refunded_;
}
inline uint64_t ProcessTransactionResponse::gas_refunded() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.gas_refunded)
  return _internal_gas_refunded();
}
inline void ProcessTransactionResponse::_internal_set_gas_refunded(uint64_t value) {
  
  _impl_.gas_refunded_ = value;
}
inline void ProcessTransactionResponse::set_gas_refunded(uint64_t value) {
  _internal_set_gas_refunded(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.gas_refunded)
}

// .executor.v1.RomError error = 8;
inline void ProcessTransactionResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError ProcessTransactionResponse::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError ProcessTransactionResponse::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.error)
  return _internal_error();
}
inline void ProcessTransactionResponse::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void ProcessTransactionResponse::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.error)
}

// string create_address = 9;
inline void ProcessTransactionResponse::clear_create_address() {
  _impl_.create_address_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::create_address() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.create_address)
  return _internal_create_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_create_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.create_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.create_address)
}
inline std::string* ProcessTransactionResponse::mutable_create_address() {
  std::string* _s = _internal_mutable_create_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.create_address)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_create_address() const {
  return _impl_.create_address_.Get();
}
inline void ProcessTransactionResponse::_internal_set_create_address(const std::string& value) {
  
  _impl_.create_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_create_address() {
  
  return _impl_.create_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_create_address() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.create_address)
  return _impl_.create_address_.Release();
}
inline void ProcessTransactionResponse::set_allocated_create_address(std::string* create_address) {
  if (create_address != nullptr) {
    
  } else {
    
  }
  _impl_.create_address_.SetAllocated(create_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.create_address_.IsDefault()) {
    _impl_.create_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.create_address)
}

// bytes state_root = 10;
inline void ProcessTransactionResponse::clear_state_root() {
  _impl_.state_root_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.state_root)
  return _internal_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.state_root)
}
inline std::string* ProcessTransactionResponse::mutable_state_root() {
  std::string* _s = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.state_root)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_state_root() const {
  return _impl_.state_root_.Get();
}
inline void ProcessTransactionResponse::_internal_set_state_root(const std::string& value) {
  
  _impl_.state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_state_root() {
  
  return _impl_.state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.state_root)
  return _impl_.state_root_.Release();
}
inline void ProcessTransactionResponse::set_allocated_state_root(std::string* state_root) {
  if (state_root != nullptr) {
    
  } else {
    
  }
  _impl_.state_root_.SetAllocated(state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_root_.IsDefault()) {
    _impl_.state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.state_root)
}

// repeated .executor.v1.Log logs = 11;
inline int ProcessTransactionResponse::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int ProcessTransactionResponse::logs_size() const {
  return _internal_logs_size();
}
inline void ProcessTransactionResponse::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::executor::v1::Log* ProcessTransactionResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >*
ProcessTransactionResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessTransactionResponse.logs)
  return &_impl_.logs_;
}
inline const ::executor::v1::Log& ProcessTransactionResponse::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::executor::v1::Log& ProcessTransactionResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.logs)
  return _internal_logs(index);
}
inline ::executor::v1::Log* ProcessTransactionResponse::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::executor::v1::Log* ProcessTransactionResponse::add_logs() {
  ::executor::v1::Log* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessTransactionResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >&
ProcessTransactionResponse::logs() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessTransactionResponse.logs)
  return _impl_.logs_;
}

// repeated .executor.v1.ExecutionTraceStep execution_trace = 13;
inline int ProcessTransactionResponse::_internal_execution_trace_size() const {
  return _impl_.execution_trace_.size();
}
inline int ProcessTransactionResponse::execution_trace_size() const {
  return _internal_execution_trace_size();
}
inline void ProcessTransactionResponse::clear_execution_trace() {
  _impl_.execution_trace_.Clear();
}
inline ::executor::v1::ExecutionTraceStep* ProcessTransactionResponse::mutable_execution_trace(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.execution_trace)
  return _impl_.execution_trace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ExecutionTraceStep >*
ProcessTransactionResponse::mutable_execution_trace() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessTransactionResponse.execution_trace)
  return &_impl_.execution_trace_;
}
inline const ::executor::v1::ExecutionTraceStep& ProcessTransactionResponse::_internal_execution_trace(int index) const {
  return _impl_.execution_trace_.Get(index);
}
inline const ::executor::v1::ExecutionTraceStep& ProcessTransactionResponse::execution_trace(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.execution_trace)
  return _internal_execution_trace(index);
}
inline ::executor::v1::ExecutionTraceStep* ProcessTransactionResponse::_internal_add_execution_trace() {
  return _impl_.execution_trace_.Add();
}
inline ::executor::v1::ExecutionTraceStep* ProcessTransactionResponse::add_execution_trace() {
  ::executor::v1::ExecutionTraceStep* _add = _internal_add_execution_trace();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessTransactionResponse.execution_trace)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ExecutionTraceStep >&
ProcessTransactionResponse::execution_trace() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessTransactionResponse.execution_trace)
  return _impl_.execution_trace_;
}

// .executor.v1.CallTrace call_trace = 14;
inline bool ProcessTransactionResponse::_internal_has_call_trace() const {
  return this != internal_default_instance() && _impl_.call_trace_ != nullptr;
}
inline bool ProcessTransactionResponse::has_call_trace() const {
  return _internal_has_call_trace();
}
inline void ProcessTransactionResponse::clear_call_trace() {
  if (GetArenaForAllocation() == nullptr && _impl_.call_trace_ != nullptr) {
    delete _impl_.call_trace_;
  }
  _impl_.call_trace_ = nullptr;
}
inline const ::executor::v1::CallTrace& ProcessTransactionResponse::_internal_call_trace() const {
  const ::executor::v1::CallTrace* p = _impl_.call_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::CallTrace&>(
      ::executor::v1::_CallTrace_default_instance_);
}
inline const ::executor::v1::CallTrace& ProcessTransactionResponse::call_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.call_trace)
  return _internal_call_trace();
}
inline void ProcessTransactionResponse::unsafe_arena_set_allocated_call_trace(
    ::executor::v1::CallTrace* call_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.call_trace_);
  }
  _impl_.call_trace_ = call_trace;
  if (call_trace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessTransactionResponse.call_trace)
}
inline ::executor::v1::CallTrace* ProcessTransactionResponse::release_call_trace() {
  
  ::executor::v1::CallTrace* temp = _impl_.call_trace_;
  _impl_.call_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::CallTrace* ProcessTransactionResponse::unsafe_arena_release_call_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.call_trace)
  
  ::executor::v1::CallTrace* temp = _impl_.call_trace_;
  _impl_.call_trace_ = nullptr;
  return temp;
}
inline ::executor::v1::CallTrace* ProcessTransactionResponse::_internal_mutable_call_trace() {
  
  if (_impl_.call_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::CallTrace>(GetArenaForAllocation());
    _impl_.call_trace_ = p;
  }
  return _impl_.call_trace_;
}
inline ::executor::v1::CallTrace* ProcessTransactionResponse::mutable_call_trace() {
  ::executor::v1::CallTrace* _msg = _internal_mutable_call_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.call_trace)
  return _msg;
}
inline void ProcessTransactionResponse::set_allocated_call_trace(::executor::v1::CallTrace* call_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.call_trace_;
  }
  if (call_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(call_trace);
    if (message_arena != submessage_arena) {
      call_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call_trace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.call_trace_ = call_trace;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.call_trace)
}

// string effective_gas_price = 15;
inline void ProcessTransactionResponse::clear_effective_gas_price() {
  _impl_.effective_gas_price_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::effective_gas_price() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.effective_gas_price)
  return _internal_effective_gas_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_effective_gas_price(ArgT0&& arg0, ArgT... args) {
 
 _impl_.effective_gas_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.effective_gas_price)
}
inline std::string* ProcessTransactionResponse::mutable_effective_gas_price() {
  std::string* _s = _internal_mutable_effective_gas_price();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.effective_gas_price)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_effective_gas_price() const {
  return _impl_.effective_gas_price_.Get();
}
inline void ProcessTransactionResponse::_internal_set_effective_gas_price(const std::string& value) {
  
  _impl_.effective_gas_price_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_effective_gas_price() {
  
  return _impl_.effective_gas_price_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_effective_gas_price() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.effective_gas_price)
  return _impl_.effective_gas_price_.Release();
}
inline void ProcessTransactionResponse::set_allocated_effective_gas_price(std::string* effective_gas_price) {
  if (effective_gas_price != nullptr) {
    
  } else {
    
  }
  _impl_.effective_gas_price_.SetAllocated(effective_gas_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.effective_gas_price_.IsDefault()) {
    _impl_.effective_gas_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.effective_gas_price)
}

// uint32 effective_percentage = 16;
inline void ProcessTransactionResponse::clear_effective_percentage() {
  _impl_.effective_percentage_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_effective_percentage() const {
  return _impl_.effective_percentage_;
}
inline uint32_t ProcessTransactionResponse::effective_percentage() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.effective_percentage)
  return _internal_effective_percentage();
}
inline void ProcessTransactionResponse::_internal_set_effective_percentage(uint32_t value) {
  
  _impl_.effective_percentage_ = value;
}
inline void ProcessTransactionResponse::set_effective_percentage(uint32_t value) {
  _internal_set_effective_percentage(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.effective_percentage)
}

// uint32 has_gasprice_opcode = 17;
inline void ProcessTransactionResponse::clear_has_gasprice_opcode() {
  _impl_.has_gasprice_opcode_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_has_gasprice_opcode() const {
  return _impl_.has_gasprice_opcode_;
}
inline uint32_t ProcessTransactionResponse::has_gasprice_opcode() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.has_gasprice_opcode)
  return _internal_has_gasprice_opcode();
}
inline void ProcessTransactionResponse::_internal_set_has_gasprice_opcode(uint32_t value) {
  
  _impl_.has_gasprice_opcode_ = value;
}
inline void ProcessTransactionResponse::set_has_gasprice_opcode(uint32_t value) {
  _internal_set_has_gasprice_opcode(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.has_gasprice_opcode)
}

// uint32 has_balance_opcode = 18;
inline void ProcessTransactionResponse::clear_has_balance_opcode() {
  _impl_.has_balance_opcode_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_has_balance_opcode() const {
  return _impl_.has_balance_opcode_;
}
inline uint32_t ProcessTransactionResponse::has_balance_opcode() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.has_balance_opcode)
  return _internal_has_balance_opcode();
}
inline void ProcessTransactionResponse::_internal_set_has_balance_opcode(uint32_t value) {
  
  _impl_.has_balance_opcode_ = value;
}
inline void ProcessTransactionResponse::set_has_balance_opcode(uint32_t value) {
  _internal_set_has_balance_opcode(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.has_balance_opcode)
}

// -------------------------------------------------------------------

// Log

// string address = 1;
inline void Log::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Log::address() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.address)
}
inline std::string* Log::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.address)
  return _s;
}
inline const std::string& Log::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Log::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_address() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.address)
  return _impl_.address_.Release();
}
inline void Log::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.address)
}

// repeated bytes topics = 2;
inline int Log::_internal_topics_size() const {
  return _impl_.topics_.size();
}
inline int Log::topics_size() const {
  return _internal_topics_size();
}
inline void Log::clear_topics() {
  _impl_.topics_.Clear();
}
inline std::string* Log::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.Log.topics)
  return _s;
}
inline const std::string& Log::_internal_topics(int index) const {
  return _impl_.topics_.Get(index);
}
inline const std::string& Log::topics(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.topics)
  return _internal_topics(index);
}
inline std::string* Log::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.topics)
  return _impl_.topics_.Mutable(index);
}
inline void Log::set_topics(int index, const std::string& value) {
  _impl_.topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.topics)
}
inline void Log::set_topics(int index, std::string&& value) {
  _impl_.topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.Log.topics)
}
inline void Log::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.Log.topics)
}
inline void Log::set_topics(int index, const void* value, size_t size) {
  _impl_.topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.Log.topics)
}
inline std::string* Log::_internal_add_topics() {
  return _impl_.topics_.Add();
}
inline void Log::add_topics(const std::string& value) {
  _impl_.topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.Log.topics)
}
inline void Log::add_topics(std::string&& value) {
  _impl_.topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.Log.topics)
}
inline void Log::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.Log.topics)
}
inline void Log::add_topics(const void* value, size_t size) {
  _impl_.topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.Log.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Log::topics() const {
  // @@protoc_insertion_point(field_list:executor.v1.Log.topics)
  return _impl_.topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Log::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.Log.topics)
  return &_impl_.topics_;
}

// bytes data = 3;
inline void Log::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Log::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.data)
}
inline std::string* Log::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.data)
  return _s;
}
inline const std::string& Log::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Log::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.data)
  return _impl_.data_.Release();
}
inline void Log::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.data)
}

// uint64 batch_number = 4;
inline void Log::clear_batch_number() {
  _impl_.batch_number_ = uint64_t{0u};
}
inline uint64_t Log::_internal_batch_number() const {
  return _impl_.batch_number_;
}
inline uint64_t Log::batch_number() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.batch_number)
  return _internal_batch_number();
}
inline void Log::_internal_set_batch_number(uint64_t value) {
  
  _impl_.batch_number_ = value;
}
inline void Log::set_batch_number(uint64_t value) {
  _internal_set_batch_number(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.batch_number)
}

// bytes tx_hash = 5;
inline void Log::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& Log::tx_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.tx_hash)
}
inline std::string* Log::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.tx_hash)
  return _s;
}
inline const std::string& Log::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void Log::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_tx_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void Log::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.tx_hash)
}

// uint32 tx_index = 6;
inline void Log::clear_tx_index() {
  _impl_.tx_index_ = 0u;
}
inline uint32_t Log::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline uint32_t Log::tx_index() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.tx_index)
  return _internal_tx_index();
}
inline void Log::_internal_set_tx_index(uint32_t value) {
  
  _impl_.tx_index_ = value;
}
inline void Log::set_tx_index(uint32_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.tx_index)
}

// bytes batch_hash = 7;
inline void Log::clear_batch_hash() {
  _impl_.batch_hash_.ClearToEmpty();
}
inline const std::string& Log::batch_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.batch_hash)
  return _internal_batch_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_batch_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.batch_hash)
}
inline std::string* Log::mutable_batch_hash() {
  std::string* _s = _internal_mutable_batch_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.batch_hash)
  return _s;
}
inline const std::string& Log::_internal_batch_hash() const {
  return _impl_.batch_hash_.Get();
}
inline void Log::_internal_set_batch_hash(const std::string& value) {
  
  _impl_.batch_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_batch_hash() {
  
  return _impl_.batch_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_batch_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.batch_hash)
  return _impl_.batch_hash_.Release();
}
inline void Log::set_allocated_batch_hash(std::string* batch_hash) {
  if (batch_hash != nullptr) {
    
  } else {
    
  }
  _impl_.batch_hash_.SetAllocated(batch_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_hash_.IsDefault()) {
    _impl_.batch_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.batch_hash)
}

// uint32 index = 8;
inline void Log::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t Log::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t Log::index() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.index)
  return _internal_index();
}
inline void Log::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void Log::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.index)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecutionTraceStep

// uint64 pc = 1;
inline void ExecutionTraceStep::clear_pc() {
  _impl_.pc_ = uint64_t{0u};
}
inline uint64_t ExecutionTraceStep::_internal_pc() const {
  return _impl_.pc_;
}
inline uint64_t ExecutionTraceStep::pc() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.pc)
  return _internal_pc();
}
inline void ExecutionTraceStep::_internal_set_pc(uint64_t value) {
  
  _impl_.pc_ = value;
}
inline void ExecutionTraceStep::set_pc(uint64_t value) {
  _internal_set_pc(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.pc)
}

// string op = 2;
inline void ExecutionTraceStep::clear_op() {
  _impl_.op_.ClearToEmpty();
}
inline const std::string& ExecutionTraceStep::op() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.op)
  return _internal_op();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionTraceStep::set_op(ArgT0&& arg0, ArgT... args) {
 
 _impl_.op_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.op)
}
inline std::string* ExecutionTraceStep::mutable_op() {
  std::string* _s = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:executor.v1.ExecutionTraceStep.op)
  return _s;
}
inline const std::string& ExecutionTraceStep::_internal_op() const {
  return _impl_.op_.Get();
}
inline void ExecutionTraceStep::_internal_set_op(const std::string& value) {
  
  _impl_.op_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionTraceStep::_internal_mutable_op() {
  
  return _impl_.op_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionTraceStep::release_op() {
  // @@protoc_insertion_point(field_release:executor.v1.ExecutionTraceStep.op)
  return _impl_.op_.Release();
}
inline void ExecutionTraceStep::set_allocated_op(std::string* op) {
  if (op != nullptr) {
    
  } else {
    
  }
  _impl_.op_.SetAllocated(op, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.op_.IsDefault()) {
    _impl_.op_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ExecutionTraceStep.op)
}

// uint64 remaining_gas = 3;
inline void ExecutionTraceStep::clear_remaining_gas() {
  _impl_.remaining_gas_ = uint64_t{0u};
}
inline uint64_t ExecutionTraceStep::_internal_remaining_gas() const {
  return _impl_.remaining_gas_;
}
inline uint64_t ExecutionTraceStep::remaining_gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.remaining_gas)
  return _internal_remaining_gas();
}
inline void ExecutionTraceStep::_internal_set_remaining_gas(uint64_t value) {
  
  _impl_.remaining_gas_ = value;
}
inline void ExecutionTraceStep::set_remaining_gas(uint64_t value) {
  _internal_set_remaining_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.remaining_gas)
}

// uint64 gas_cost = 4;
inline void ExecutionTraceStep::clear_gas_cost() {
  _impl_.gas_cost_ = uint64_t{0u};
}
inline uint64_t ExecutionTraceStep::_internal_gas_cost() const {
  return _impl_.gas_cost_;
}
inline uint64_t ExecutionTraceStep::gas_cost() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.gas_cost)
  return _internal_gas_cost();
}
inline void ExecutionTraceStep::_internal_set_gas_cost(uint64_t value) {
  
  _impl_.gas_cost_ = value;
}
inline void ExecutionTraceStep::set_gas_cost(uint64_t value) {
  _internal_set_gas_cost(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.gas_cost)
}

// bytes memory = 5;
inline void ExecutionTraceStep::clear_memory() {
  _impl_.memory_.ClearToEmpty();
}
inline const std::string& ExecutionTraceStep::memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.memory)
  return _internal_memory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionTraceStep::set_memory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.memory)
}
inline std::string* ExecutionTraceStep::mutable_memory() {
  std::string* _s = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:executor.v1.ExecutionTraceStep.memory)
  return _s;
}
inline const std::string& ExecutionTraceStep::_internal_memory() const {
  return _impl_.memory_.Get();
}
inline void ExecutionTraceStep::_internal_set_memory(const std::string& value) {
  
  _impl_.memory_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionTraceStep::_internal_mutable_memory() {
  
  return _impl_.memory_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionTraceStep::release_memory() {
  // @@protoc_insertion_point(field_release:executor.v1.ExecutionTraceStep.memory)
  return _impl_.memory_.Release();
}
inline void ExecutionTraceStep::set_allocated_memory(std::string* memory) {
  if (memory != nullptr) {
    
  } else {
    
  }
  _impl_.memory_.SetAllocated(memory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memory_.IsDefault()) {
    _impl_.memory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ExecutionTraceStep.memory)
}

// uint32 memory_size = 6;
inline void ExecutionTraceStep::clear_memory_size() {
  _impl_.memory_size_ = 0u;
}
inline uint32_t ExecutionTraceStep::_internal_memory_size() const {
  return _impl_.memory_size_;
}
inline uint32_t ExecutionTraceStep::memory_size() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.memory_size)
  return _internal_memory_size();
}
inline void ExecutionTraceStep::_internal_set_memory_size(uint32_t value) {
  
  _impl_.memory_size_ = value;
}
inline void ExecutionTraceStep::set_memory_size(uint32_t value) {
  _internal_set_memory_size(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.memory_size)
}

// uint32 memory_offset = 7;
inline void ExecutionTraceStep::clear_memory_offset() {
  _impl_.memory_offset_ = 0u;
}
inline uint32_t ExecutionTraceStep::_internal_memory_offset() const {
  return _impl_.memory_offset_;
}
inline uint32_t ExecutionTraceStep::memory_offset() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.memory_offset)
  return _internal_memory_offset();
}
inline void ExecutionTraceStep::_internal_set_memory_offset(uint32_t value) {
  
  _impl_.memory_offset_ = value;
}
inline void ExecutionTraceStep::set_memory_offset(uint32_t value) {
  _internal_set_memory_offset(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.memory_offset)
}

// repeated string stack = 8;
inline int ExecutionTraceStep::_internal_stack_size() const {
  return _impl_.stack_.size();
}
inline int ExecutionTraceStep::stack_size() const {
  return _internal_stack_size();
}
inline void ExecutionTraceStep::clear_stack() {
  _impl_.stack_.Clear();
}
inline std::string* ExecutionTraceStep::add_stack() {
  std::string* _s = _internal_add_stack();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.ExecutionTraceStep.stack)
  return _s;
}
inline const std::string& ExecutionTraceStep::_internal_stack(int index) const {
  return _impl_.stack_.Get(index);
}
inline const std::string& ExecutionTraceStep::stack(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.stack)
  return _internal_stack(index);
}
inline std::string* ExecutionTraceStep::mutable_stack(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ExecutionTraceStep.stack)
  return _impl_.stack_.Mutable(index);
}
inline void ExecutionTraceStep::set_stack(int index, const std::string& value) {
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.stack)
}
inline void ExecutionTraceStep::set_stack(int index, std::string&& value) {
  _impl_.stack_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.stack)
}
inline void ExecutionTraceStep::set_stack(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.ExecutionTraceStep.stack)
}
inline void ExecutionTraceStep::set_stack(int index, const char* value, size_t size) {
  _impl_.stack_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.ExecutionTraceStep.stack)
}
inline std::string* ExecutionTraceStep::_internal_add_stack() {
  return _impl_.stack_.Add();
}
inline void ExecutionTraceStep::add_stack(const std::string& value) {
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.ExecutionTraceStep.stack)
}
inline void ExecutionTraceStep::add_stack(std::string&& value) {
  _impl_.stack_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.ExecutionTraceStep.stack)
}
inline void ExecutionTraceStep::add_stack(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.ExecutionTraceStep.stack)
}
inline void ExecutionTraceStep::add_stack(const char* value, size_t size) {
  _impl_.stack_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.ExecutionTraceStep.stack)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecutionTraceStep::stack() const {
  // @@protoc_insertion_point(field_list:executor.v1.ExecutionTraceStep.stack)
  return _impl_.stack_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecutionTraceStep::mutable_stack() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ExecutionTraceStep.stack)
  return &_impl_.stack_;
}

// bytes return_data = 9;
inline void ExecutionTraceStep::clear_return_data() {
  _impl_.return_data_.ClearToEmpty();
}
inline const std::string& ExecutionTraceStep::return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.return_data)
  return _internal_return_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionTraceStep::set_return_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.return_data)
}
inline std::string* ExecutionTraceStep::mutable_return_data() {
  std::string* _s = _internal_mutable_return_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.ExecutionTraceStep.return_data)
  return _s;
}
inline const std::string& ExecutionTraceStep::_internal_return_data() const {
  return _impl_.return_data_.Get();
}
inline void ExecutionTraceStep::_internal_set_return_data(const std::string& value) {
  
  _impl_.return_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionTraceStep::_internal_mutable_return_data() {
  
  return _impl_.return_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionTraceStep::release_return_data() {
  // @@protoc_insertion_point(field_release:executor.v1.ExecutionTraceStep.return_data)
  return _impl_.return_data_.Release();
}
inline void ExecutionTraceStep::set_allocated_return_data(std::string* return_data) {
  if (return_data != nullptr) {
    
  } else {
    
  }
  _impl_.return_data_.SetAllocated(return_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_data_.IsDefault()) {
    _impl_.return_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ExecutionTraceStep.return_data)
}

// map<string, string> storage = 10;
inline int ExecutionTraceStep::_internal_storage_size() const {
  return _impl_.storage_.size();
}
inline int ExecutionTraceStep::storage_size() const {
  return _internal_storage_size();
}
inline void ExecutionTraceStep::clear_storage() {
  _impl_.storage_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExecutionTraceStep::_internal_storage() const {
  return _impl_.storage_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExecutionTraceStep::storage() const {
  // @@protoc_insertion_point(field_map:executor.v1.ExecutionTraceStep.storage)
  return _internal_storage();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExecutionTraceStep::_internal_mutable_storage() {
  return _impl_.storage_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExecutionTraceStep::mutable_storage() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ExecutionTraceStep.storage)
  return _internal_mutable_storage();
}

// uint32 depth = 11;
inline void ExecutionTraceStep::clear_depth() {
  _impl_.depth_ = 0u;
}
inline uint32_t ExecutionTraceStep::_internal_depth() const {
  return _impl_.depth_;
}
inline uint32_t ExecutionTraceStep::depth() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.depth)
  return _internal_depth();
}
inline void ExecutionTraceStep::_internal_set_depth(uint32_t value) {
  
  _impl_.depth_ = value;
}
inline void ExecutionTraceStep::set_depth(uint32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.depth)
}

// uint64 gas_refund = 12;
inline void ExecutionTraceStep::clear_gas_refund() {
  _impl_.gas_refund_ = uint64_t{0u};
}
inline uint64_t ExecutionTraceStep::_internal_gas_refund() const {
  return _impl_.gas_refund_;
}
inline uint64_t ExecutionTraceStep::gas_refund() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.gas_refund)
  return _internal_gas_refund();
}
inline void ExecutionTraceStep::_internal_set_gas_refund(uint64_t value) {
  
  _impl_.gas_refund_ = value;
}
inline void ExecutionTraceStep::set_gas_refund(uint64_t value) {
  _internal_set_gas_refund(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.gas_refund)
}

// .executor.v1.RomError error = 13;
inline void ExecutionTraceStep::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError ExecutionTraceStep::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError ExecutionTraceStep::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ExecutionTraceStep.error)
  return _internal_error();
}
inline void ExecutionTraceStep::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void ExecutionTraceStep::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ExecutionTraceStep.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace executor

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::executor::v1::RomError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::executor::v1::RomError>() {
  return ::executor::v1::RomError_descriptor();
}
template <> struct is_proto_enum< ::executor::v1::ExecutorError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::executor::v1::ExecutorError>() {
  return ::executor::v1::ExecutorError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_executor_2eproto
